{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"source/favicon.ico","path":"favicon.ico","modified":0,"renderable":0},{"_id":"themes/ad/source/css/index.css","path":"css/index.css","modified":0,"renderable":1},{"_id":"themes/ad/source/images/favicon.ico","path":"images/favicon.ico","modified":0,"renderable":1},{"_id":"themes/ad/source/images/alipay.png","path":"images/alipay.png","modified":0,"renderable":1},{"_id":"themes/ad/source/images/touch-icon.png","path":"images/touch-icon.png","modified":0,"renderable":1},{"_id":"themes/ad/source/images/wechat.png","path":"images/wechat.png","modified":0,"renderable":1},{"_id":"themes/ad/source/styles/global.scss","path":"styles/global.scss","modified":0,"renderable":1},{"_id":"themes/ad/source/styles/index.scss","path":"styles/index.scss","modified":0,"renderable":1},{"_id":"themes/ad/source/js/auth.js","path":"js/auth.js","modified":0,"renderable":1},{"_id":"themes/ad/source/js/backTop.js","path":"js/backTop.js","modified":0,"renderable":1},{"_id":"themes/ad/source/js/copy.js","path":"js/copy.js","modified":0,"renderable":1},{"_id":"themes/ad/source/js/header.js","path":"js/header.js","modified":0,"renderable":1},{"_id":"themes/ad/source/js/index.js","path":"js/index.js","modified":0,"renderable":1},{"_id":"themes/ad/source/js/layer.js","path":"js/layer.js","modified":0,"renderable":1},{"_id":"themes/ad/source/js/leancloud.js","path":"js/leancloud.js","modified":0,"renderable":1},{"_id":"themes/ad/source/js/mathjax.js","path":"js/mathjax.js","modified":0,"renderable":1},{"_id":"themes/ad/source/js/passage.js","path":"js/passage.js","modified":0,"renderable":1},{"_id":"themes/ad/source/js/reward.js","path":"js/reward.js","modified":0,"renderable":1},{"_id":"themes/ad/source/js/scroll.js","path":"js/scroll.js","modified":0,"renderable":1},{"_id":"themes/ad/source/js/share.js","path":"js/share.js","modified":0,"renderable":1},{"_id":"themes/ad/source/js/time.js","path":"js/time.js","modified":0,"renderable":1},{"_id":"themes/ad/source/vendor/qrcode.min.js","path":"vendor/qrcode.min.js","modified":0,"renderable":1},{"_id":"themes/ad/source/vendor/sha256.min.js","path":"vendor/sha256.min.js","modified":0,"renderable":1},{"_id":"themes/ad/source/styles/components/bottom-bar.scss","path":"styles/components/bottom-bar.scss","modified":0,"renderable":1},{"_id":"themes/ad/source/styles/components/comment.scss","path":"styles/components/comment.scss","modified":0,"renderable":1},{"_id":"themes/ad/source/styles/components/index.scss","path":"styles/components/index.scss","modified":0,"renderable":1},{"_id":"themes/ad/source/styles/components/layer.scss","path":"styles/components/layer.scss","modified":0,"renderable":1},{"_id":"themes/ad/source/styles/components/share.scss","path":"styles/components/share.scss","modified":0,"renderable":1},{"_id":"themes/ad/source/styles/components/toc.scss","path":"styles/components/toc.scss","modified":0,"renderable":1},{"_id":"themes/ad/source/styles/layout/about.scss","path":"styles/layout/about.scss","modified":0,"renderable":1},{"_id":"themes/ad/source/styles/layout/friend.scss","path":"styles/layout/friend.scss","modified":0,"renderable":1},{"_id":"themes/ad/source/styles/layout/home.scss","path":"styles/layout/home.scss","modified":0,"renderable":1},{"_id":"themes/ad/source/styles/layout/index.scss","path":"styles/layout/index.scss","modified":0,"renderable":1},{"_id":"themes/ad/source/styles/layout/passage.scss","path":"styles/layout/passage.scss","modified":0,"renderable":1},{"_id":"themes/ad/source/styles/layout/set.scss","path":"styles/layout/set.scss","modified":0,"renderable":1},{"_id":"themes/ad/source/styles/layout/timeline.scss","path":"styles/layout/timeline.scss","modified":0,"renderable":1},{"_id":"themes/ad/source/styles/mixins/color.scss","path":"styles/mixins/color.scss","modified":0,"renderable":1},{"_id":"themes/ad/source/styles/mixins/font.scss","path":"styles/mixins/font.scss","modified":0,"renderable":1},{"_id":"themes/ad/source/styles/mixins/index.scss","path":"styles/mixins/index.scss","modified":0,"renderable":1},{"_id":"themes/ad/source/styles/partials/footer.scss","path":"styles/partials/footer.scss","modified":0,"renderable":1},{"_id":"themes/ad/source/styles/partials/header.scss","path":"styles/partials/header.scss","modified":0,"renderable":1},{"_id":"themes/ad/source/styles/partials/index.scss","path":"styles/partials/index.scss","modified":0,"renderable":1},{"_id":"themes/ad/source/styles/components/highlight/highlight.styl","path":"styles/components/highlight/highlight.styl","modified":0,"renderable":1},{"_id":"themes/ad/source/styles/components/highlight/diff.styl","path":"styles/components/highlight/diff.styl","modified":0,"renderable":1},{"_id":"themes/ad/source/styles/components/highlight/theme.styl","path":"styles/components/highlight/theme.styl","modified":0,"renderable":1},{"_id":"themes/ad/source/styles/components/highlight/var.styl","path":"styles/components/highlight/var.styl","modified":0,"renderable":1}],"Cache":[{"_id":"source/.DS_Store","hash":"dbc93933f6ab21c45dc80f80f065ca1da76c044d","modified":1543324480835},{"_id":"source/404.html","hash":"050442d7267c89daef3dae09a4809c179f26c7f8","modified":1538839489819},{"_id":"source/favicon.ico","hash":"e2a9e90adda6b803a273bfadaf23b47c584fd5e1","modified":1546317120045},{"_id":"themes/ad/.gitignore","hash":"e20641fcd2ac0626c1dbe4aadfea842836049a5c","modified":1551796671354},{"_id":"themes/ad/LICENSE","hash":"3f8a68c846958c6e4dcd7bdacd016c0711553a98","modified":1551796671354},{"_id":"themes/ad/README.cn.md","hash":"08ee9e4722af0f137ec6eece08f26ec046259d2b","modified":1553946910332},{"_id":"themes/ad/README.md","hash":"9f6b59b2d4de08a08de76aa87ecc6d1a4757ac07","modified":1553946910332},{"_id":"themes/ad/_config.yml","hash":"780ff912fd44b2f813aa3befc3980b7278a87086","modified":1553952988654},{"_id":"themes/ad/package.json","hash":"90b47ed3b531489797112c22e984f00baefac808","modified":1551796671359},{"_id":"themes/ad/.DS_Store","hash":"46b6902dfd7af8b7dc16ff15daa24d12c0015669","modified":1553951643567},{"_id":"source/_posts/2018-10-06-vscode下-vue文件初始化.md","hash":"a71aa57fc06d853e4fba15b28701fe0922dd8c3c","modified":1551797617175},{"_id":"source/_posts/2018-10-06-vscode格式化vue文件.md","hash":"edc16cb074ec3192c7495cb7788bedab6277fc5a","modified":1551797630054},{"_id":"source/_posts/2018-11-03-Vue在安卓低版本兼容问题.md","hash":"7b5aafa5c71e412f8a46c5cd3b2e789c7f590a2a","modified":1551797670311},{"_id":"source/_posts/2018-11-03-Vue脚手架创建的时候卡在Download-https-chromedriver-storage.md","hash":"ca193c46175809225951c15b5cb109fd328a4cd4","modified":1553950567027},{"_id":"source/_posts/2019-01-01-Vue中使用px2rem把px转换为rem.md","hash":"c1dfb4c57aa3f84b0a3d0348474493c62f189cfa","modified":1551797643771},{"_id":"source/_posts/2019-01-01-Vue中使用scss和sass语法.md","hash":"830701d6771879de89b5acbd98d4b93ab6b3ad9d","modified":1551797658023},{"_id":"source/_posts/2019-01-02-promise使用.md","hash":"088f40e5affcb803448a67cd929a27c052b45842","modified":1551797605566},{"_id":"source/_posts/2019-01-29-ES2015中class基本语法.md","hash":"1423425c8392dc41181bc140fc570065312b1aea","modified":1551797557233},{"_id":"source/_posts/2019-01-31-JavaScript中this指向问题（含ES6）.md","hash":"d75b717ae512dc060c8004f0ab15e5b9e9eccda4","modified":1551797575544},{"_id":"source/_posts/2019-01-31-JavaScript中的原型链.md","hash":"be9145bab43195835ce0cad73c059e76fc99af15","modified":1551797590035},{"_id":"source/_posts/2019-02-25-详解addEventListener.md","hash":"2488e7620408716b69f4974c6a6368a79ab3500a","modified":1551798355107},{"_id":"source/_posts/这些年我究竟失去了什么.md","hash":"5d33946063647565339f3289392219936bc0535b","modified":1551942405550},{"_id":"source/about/index.md","hash":"5b730283e93947c3ece6f2948fa4e2d85890dec7","modified":1553950855325},{"_id":"source/categories/index.md","hash":"d9d0f15f5bea5ae76f31854cef328d97cc109d50","modified":1538814248999},{"_id":"source/tags/index.md","hash":"77aba225644b46360facf029b416dc16306913f6","modified":1538814249000},{"_id":"themes/ad/.github/ISSUE_TEMPLATE.md","hash":"9607a2be2fe5ecffffa0eabfda6000b510304766","modified":1553946910331},{"_id":"themes/ad/.github/PULL_REQUEST_TEMPLATE.md","hash":"9617456a790f19436d65d063ec77f811a6517b47","modified":1553946910332},{"_id":"themes/ad/.git备用/FETCH_HEAD","hash":"732ee8734ca38a6bef0fd012fc7dedb1d56cb638","modified":1553946910308},{"_id":"themes/ad/.git备用/HEAD","hash":"acbaef275e46a7f14c1ef456fff2c8bbe8c84724","modified":1551796671346},{"_id":"themes/ad/.git备用/ORIG_HEAD","hash":"2783c13341769b57ff9e24521d916413d59a39b3","modified":1553946910327},{"_id":"themes/ad/.git备用/config","hash":"3e92638d7361d83dc1ce028327d65f3d2b87cb08","modified":1551796671348},{"_id":"themes/ad/.git备用/description","hash":"9635f1b7e12c045212819dd934d809ef07efa2f4","modified":1551796666849},{"_id":"themes/ad/.git备用/index","hash":"497af7227b0e95eb4767327adfc79bea7c966c0f","modified":1553946910349},{"_id":"themes/ad/.git备用/packed-refs","hash":"be089a31eeeefdddcf5dfd9b56b48c730a6d65a4","modified":1551796671344},{"_id":"themes/ad/layout/about.ejs","hash":"79126abf089aed94d5a2e54dd4b68cd1a122d06d","modified":1551796671355},{"_id":"themes/ad/layout/archive.ejs","hash":"d5b01b0108b300c70375428902033e20557f25de","modified":1551796671355},{"_id":"themes/ad/layout/categories.ejs","hash":"9e87269bab4a4b03049377e2d4fda934c12544e1","modified":1551796671355},{"_id":"themes/ad/layout/category.ejs","hash":"94d5cbba18a3c3bb78c8604df5fd2c965af5399e","modified":1551796671356},{"_id":"themes/ad/layout/friends.ejs","hash":"0e5200c5536c0e1d3d7bbb22405ab82b772cafce","modified":1553946910335},{"_id":"themes/ad/layout/index.ejs","hash":"34c6cc17e7e5217de8f79f4d70c9e822a88b53d8","modified":1553946910336},{"_id":"themes/ad/layout/layout.ejs","hash":"4543d2197bb0054187f1961e894deb3c3fff3149","modified":1553946910337},{"_id":"themes/ad/layout/passage.ejs","hash":"7ae0f63287bb9741f879f0ccd90953f14b45d754","modified":1553946910339},{"_id":"themes/ad/layout/post.ejs","hash":"ef7268667a62fcbd79536ed27c8e9fcfc0a271f1","modified":1551796671359},{"_id":"themes/ad/layout/tag.ejs","hash":"14de99514531f8f38b0045d1a0426cbdebea7eda","modified":1551796671359},{"_id":"themes/ad/layout/tags.ejs","hash":"b33acb595fb0c2336f5c7d3d311192afc74dad2e","modified":1551796671359},{"_id":"themes/ad/scripts/filter.js","hash":"d8970c0dbb64193988fa7328dfc4b799c4553710","modified":1551796671360},{"_id":"themes/ad/.git备用/hooks/applypatch-msg.sample","hash":"4de88eb95a5e93fd27e78b5fb3b5231a8d8917dd","modified":1551796666851},{"_id":"themes/ad/.git备用/hooks/commit-msg.sample","hash":"ee1ed5aad98a435f2020b6de35c173b75d9affac","modified":1551796666849},{"_id":"themes/ad/.git备用/hooks/fsmonitor-watchman.sample","hash":"f7c0aa40cb0d620ff0bca3efe3521ec79e5d7156","modified":1551796666852},{"_id":"themes/ad/.git备用/hooks/post-update.sample","hash":"b614c2f63da7dca9f1db2e7ade61ef30448fc96c","modified":1551796666853},{"_id":"themes/ad/.git备用/hooks/pre-applypatch.sample","hash":"f208287c1a92525de9f5462e905a9d31de1e2d75","modified":1551796666854},{"_id":"themes/ad/.git备用/hooks/pre-commit.sample","hash":"33729ad4ce51acda35094e581e4088f3167a0af8","modified":1551796666851},{"_id":"themes/ad/.git备用/hooks/pre-push.sample","hash":"5c8518bfd1d1d3d2c1a7194994c0a16d8a313a41","modified":1551796666854},{"_id":"themes/ad/.git备用/hooks/pre-rebase.sample","hash":"288efdc0027db4cfd8b7c47c4aeddba09b6ded12","modified":1551796666850},{"_id":"themes/ad/.git备用/hooks/pre-receive.sample","hash":"705a17d259e7896f0082fe2e9f2c0c3b127be5ac","modified":1551796666852},{"_id":"themes/ad/.git备用/hooks/prepare-commit-msg.sample","hash":"2584806ba147152ae005cb675aa4f01d5d068456","modified":1551796666853},{"_id":"themes/ad/.git备用/hooks/update.sample","hash":"e729cd61b27c128951d139de8e7c63d1a3758dde","modified":1551796666855},{"_id":"themes/ad/.git备用/info/exclude","hash":"bb5a85730dcf100facee799c05cc4f6affec0745","modified":1551796666848},{"_id":"themes/ad/.git备用/logs/HEAD","hash":"c6d13e2a3194026fec29e3d71531d194627148ec","modified":1553946910351},{"_id":"themes/ad/layout/components/analytics.ejs","hash":"f526fa556a8d1d734249bb20c03acfcadf895e8f","modified":1551796671356},{"_id":"themes/ad/layout/components/bottom-bar.ejs","hash":"91959c7b00865722ca43a0e962d7723cdcc74503","modified":1553946910333},{"_id":"themes/ad/layout/components/comment.ejs","hash":"2765528e51e250d99561ce40993302e7f41d55d5","modified":1553946910334},{"_id":"themes/ad/layout/components/config.ejs","hash":"361cbdcd2b912cd1c1f47570b9b1a7ac10596a9b","modified":1553946910334},{"_id":"themes/ad/layout/components/layer.ejs","hash":"bb8a0dd20ee1c5dfe9bcf6c32d9129b53bd7dee3","modified":1553946910334},{"_id":"themes/ad/layout/components/share.ejs","hash":"edc5d7ce0390634d6c1af809ba0e1477842f0b5a","modified":1551796671357},{"_id":"themes/ad/layout/components/toc.ejs","hash":"80169c8926818d28005f9177d625ffc3688b3d96","modified":1553946910335},{"_id":"themes/ad/layout/partials/footer.ejs","hash":"3594bb9aa5a9db20f03b2d03fde2645084106a7b","modified":1553946910337},{"_id":"themes/ad/layout/partials/head.ejs","hash":"3c56466b8dd5f7b8c37e8c6116757a0879b5948e","modified":1553946910338},{"_id":"themes/ad/layout/partials/header.ejs","hash":"5e663c7c295c060446a0f268c213f34662f7fdf3","modified":1553946910339},{"_id":"themes/ad/source/css/index.css","hash":"1b26e6c669581e76df2337062f0c13d3a4c97d23","modified":1553946910341},{"_id":"themes/ad/source/images/favicon.ico","hash":"cc7c201861748e92f4809507096df74a40ef496a","modified":1551796671361},{"_id":"themes/ad/source/images/alipay.png","hash":"d58434f2543e983ecb2e2240d92bdc825e40fa60","modified":1551796671361},{"_id":"themes/ad/source/images/touch-icon.png","hash":"df5a490c2e8d549ca767505fbe46eed3cbe3df43","modified":1551796671361},{"_id":"themes/ad/source/images/wechat.png","hash":"4742a2f020b5be1d9b12681faaeace8a7c91c570","modified":1551796671361},{"_id":"themes/ad/source/styles/global.scss","hash":"e57778be87e9e750c3de5406e361cac85d5f07c3","modified":1553946910346},{"_id":"themes/ad/source/styles/index.scss","hash":"157f920a729437f0d3599d73bc211935e7d942c7","modified":1551796671366},{"_id":"themes/ad/source/js/auth.js","hash":"94508e5db3ea64f5a913ccfb05e04ecf51361395","modified":1553946910341},{"_id":"themes/ad/source/js/backTop.js","hash":"237a50a872e2fe8343353bbe18fabb3c1681f0d0","modified":1551796671362},{"_id":"themes/ad/source/js/copy.js","hash":"902fe6c84d2ebbfb37e1f91f37646bea20db8c05","modified":1553946910342},{"_id":"themes/ad/source/js/header.js","hash":"c758cb821ed923f45fae608d333c6935adc38f3d","modified":1553946910342},{"_id":"themes/ad/source/js/index.js","hash":"2575e6a1cd7d30e006862bedbefc034220401da0","modified":1553946910343},{"_id":"themes/ad/source/js/layer.js","hash":"dc17348c7bef8a78f9a258d2f25864853ee4a576","modified":1551796671362},{"_id":"themes/ad/source/js/leancloud.js","hash":"e91b45003ab747ca9162f83d033a572b00c86be5","modified":1551796671362},{"_id":"themes/ad/source/js/mathjax.js","hash":"3c58ffe041c6e124c5d927d0e7127659b562cfd8","modified":1551796671363},{"_id":"themes/ad/source/js/passage.js","hash":"cff41ceccdeefb44473d0b928c8c7f695502896a","modified":1551796671363},{"_id":"themes/ad/source/js/reward.js","hash":"6b7cec619073de3380a7e3d0b4f96f6c22db93d4","modified":1551796671363},{"_id":"themes/ad/source/js/scroll.js","hash":"938dd852f6ac214f8ad0135fce7a8b126c36ef7c","modified":1551796671363},{"_id":"themes/ad/source/js/share.js","hash":"4fcb58fe1d5332cb59f3d559401231ba8106ee2b","modified":1551796671363},{"_id":"themes/ad/source/js/time.js","hash":"4b86b54eea0bbdd8870af6c70443b852393c457b","modified":1553946910344},{"_id":"themes/ad/source/vendor/qrcode.min.js","hash":"2d06c1f823f34c19981c6ae0b0eb0f5861c5e14b","modified":1551796671369},{"_id":"themes/ad/source/vendor/sha256.min.js","hash":"3c5ff30e1f6d37786a336c407defaf5bb7bb258a","modified":1551796671369},{"_id":"themes/ad/.git备用/objects/pack/pack-69a5d74e923918027d953bda4a9125f88a22e912.idx","hash":"2c7c7d85db3c8e8f39f771b83431a79a6086c0c4","modified":1551796671326},{"_id":"themes/ad/.git备用/objects/pack/pack-fdb0d3d6cbb977012cbe5047f76557e3a440fc02.idx","hash":"1667d79bdf78f948d1f7053ef640a4212f7348a6","modified":1553946910280},{"_id":"themes/ad/.git备用/refs/heads/master","hash":"a9884150eeebed781f096839b73bf6f621113236","modified":1553946910350},{"_id":"themes/ad/.git备用/objects/pack/pack-fdb0d3d6cbb977012cbe5047f76557e3a440fc02.pack","hash":"a19ecbfa9a1a698ab4b253a8e80594252f7447ed","modified":1553946910278},{"_id":"themes/ad/.git备用/refs/tags/v2.1.0","hash":"a667692b13efaf08039cc5b58e7868a1777e8368","modified":1553946910306},{"_id":"themes/ad/.git备用/refs/tags/v2.1.1","hash":"4a041971e784b1a58cfa25f4d2899a9fbf58c480","modified":1553946910307},{"_id":"themes/ad/.git备用/refs/tags/v2.1.2","hash":"2a35c9ab5e3e26ea446c4c5abf4845ec13aa2924","modified":1553946910307},{"_id":"themes/ad/.git备用/refs/tags/v2.3.0","hash":"2298cd367f6c82e97e4d1547ee44a3f673a553fe","modified":1553946910308},{"_id":"themes/ad/.git备用/refs/tags/v2.4.0","hash":"a9884150eeebed781f096839b73bf6f621113236","modified":1553946910292},{"_id":"themes/ad/source/styles/components/bottom-bar.scss","hash":"f000e077744775c12c278af3b3b5200445a46370","modified":1551796671364},{"_id":"themes/ad/source/styles/components/comment.scss","hash":"1b9621b1d70c715a694d28517987e73bf2784d1a","modified":1553946910345},{"_id":"themes/ad/source/styles/components/index.scss","hash":"59a07eb2af79a13b2d0ffed99f6a9f73d7d4dc51","modified":1551796671365},{"_id":"themes/ad/source/styles/components/layer.scss","hash":"c65d4eba57c3332bb72257e949df1f2e02376c11","modified":1551796671365},{"_id":"themes/ad/source/styles/components/share.scss","hash":"82907f1f237eba3ac6ac33cf0208fc8fce8a52c5","modified":1551796671365},{"_id":"themes/ad/source/styles/components/toc.scss","hash":"4d724a87b55edca2c124f107550a2a0852eb301e","modified":1553946910346},{"_id":"themes/ad/source/styles/layout/about.scss","hash":"5653765541ecab79cf22099d12b33bb43cd1df9f","modified":1551796671366},{"_id":"themes/ad/source/styles/layout/friend.scss","hash":"6e0a87d8cf670946df1a9bc58183dc2cf455d3b8","modified":1551796671366},{"_id":"themes/ad/source/styles/layout/home.scss","hash":"74377081d7065bb2f9819463bbcebd719a5423bf","modified":1551796671367},{"_id":"themes/ad/source/styles/layout/index.scss","hash":"1b3c2e2c3ad6d838e6486b5dfacc7b68ebbebb94","modified":1551796671367},{"_id":"themes/ad/source/styles/layout/passage.scss","hash":"0d2550448537c73c81c934c243ac391ec193b59f","modified":1553946910347},{"_id":"themes/ad/source/styles/layout/set.scss","hash":"ed99c8ff9778815dd15d8649676957c893b0ecf2","modified":1551796671367},{"_id":"themes/ad/source/styles/layout/timeline.scss","hash":"e4b7d6ce2508e986faf2e8cc4c3d975ffb096e92","modified":1553946910348},{"_id":"themes/ad/source/styles/mixins/color.scss","hash":"fc9b234fd5a55167ee6df0d15b620af987584be5","modified":1551796671368},{"_id":"themes/ad/source/styles/mixins/font.scss","hash":"4e3320626526b26cb9a95043cc3cad3c4b0ac17d","modified":1553946910348},{"_id":"themes/ad/source/styles/mixins/index.scss","hash":"0a92b657aeb5d176501bb2dc5a9b2d4137f23192","modified":1553946910348},{"_id":"themes/ad/source/styles/partials/footer.scss","hash":"3c664b6e9dae7f9c70faffa6884bc8109254b020","modified":1553946910349},{"_id":"themes/ad/source/styles/partials/header.scss","hash":"66dbe05cff7ca389ba33617fbed33ca77b20c6ef","modified":1553946910349},{"_id":"themes/ad/source/styles/partials/index.scss","hash":"40d727b8b464e174a1f0fa2da16aa28ce7792cc7","modified":1551796671369},{"_id":"themes/ad/.git备用/logs/refs/heads/master","hash":"c6d13e2a3194026fec29e3d71531d194627148ec","modified":1553946910351},{"_id":"themes/ad/.git备用/refs/remotes/origin/HEAD","hash":"d9427cda09aba1cdde5c69c2b13c905bddb0bc51","modified":1551796671346},{"_id":"themes/ad/.git备用/refs/remotes/origin/develop","hash":"f53887e8de7c8cf678d5ad6adb055625c757b4b1","modified":1553946910292},{"_id":"themes/ad/.git备用/refs/remotes/origin/master","hash":"a9884150eeebed781f096839b73bf6f621113236","modified":1553946910289},{"_id":"themes/ad/source/styles/components/highlight/highlight.styl","hash":"afa8fa51efef45911720a6f18b7696c608fdd7c2","modified":1553946910345},{"_id":"themes/ad/source/styles/components/highlight/diff.styl","hash":"0e7e77c4d13b436d67411c743b2de0a4c9d629c2","modified":1551796671364},{"_id":"themes/ad/source/styles/components/highlight/theme.styl","hash":"3559fdc4d9a39abdb78077383de8237fe31c2d84","modified":1551796671365},{"_id":"themes/ad/source/styles/components/highlight/var.styl","hash":"3c84c1b2ea98abc97490190ae8f85b5a865b24e3","modified":1551796671365},{"_id":"themes/ad/.git备用/objects/pack/pack-69a5d74e923918027d953bda4a9125f88a22e912.pack","hash":"a8a1060201f9bb52932ff4620da8354ecb955eaf","modified":1551796671325},{"_id":"themes/ad/.git备用/logs/refs/remotes/origin/HEAD","hash":"8af85e276d4ae47d025314365ebce62ceb38af2c","modified":1551796671345},{"_id":"themes/ad/.git备用/logs/refs/remotes/origin/develop","hash":"cb83c7f359ca0d7b1a284cec72a07d16e202a1cb","modified":1553946910292},{"_id":"themes/ad/.git备用/logs/refs/remotes/origin/master","hash":"c290dccd2d0bba97a5c824a8a435456794539d82","modified":1553946910290},{"_id":"public/404.html","hash":"dd2813930eb783e23e9cea6b71c6abbb87c62623","modified":1553951662551},{"_id":"public/about/index.html","hash":"18c316c88b0f316817f2fa7a0741db8257eb4586","modified":1553951662552},{"_id":"public/categories/index.html","hash":"17681c228b2ac9bdfb4cb4b852aa2bb99b30a660","modified":1553951662552},{"_id":"public/tags/index.html","hash":"db9567f562ee38489799294eaeb93bd4e5a551d7","modified":1553951662552},{"_id":"public/undefined/这些年我究竟失去了什么/index.html","hash":"096168416d7d2f3dbef809751f8ae340083d07dd","modified":1553951662552},{"_id":"public/undefined/2019-02-25-详解addEventListener/index.html","hash":"5a85618c59f559fca84070f599acbd34c6f47326","modified":1553951662552},{"_id":"public/undefined/2019-01-31-JavaScript中this指向问题（含ES6）/index.html","hash":"40d38f80c0cee74162cb76c84bfe68700330505b","modified":1553951662552},{"_id":"public/undefined/2019-01-31-JavaScript中的原型链/index.html","hash":"ee62379dd612cae584eec98d92f370400fe9eed4","modified":1553951662552},{"_id":"public/undefined/2019-01-02-promise使用/index.html","hash":"b1760931a802a6825d62cd57ff7efe3edc83d5fc","modified":1553951662552},{"_id":"public/undefined/2018-11-03-Vue脚手架创建的时候卡在Download-https-chromedriver-storage/index.html","hash":"181bfc2e81f4b51105be064b9f8c234a02325c1b","modified":1553951662552},{"_id":"public/undefined/2018-11-03-Vue在安卓低版本兼容问题/index.html","hash":"5b0350bbaa765a2b91459ddb8a49e77dfaec9d0b","modified":1553951662552},{"_id":"public/undefined/2018-10-06-vscode下-vue文件初始化/index.html","hash":"fe84a33ceb9dc090b621ee66994fc977e4239890","modified":1553951662553},{"_id":"public/undefined/2018-10-06-vscode格式化vue文件/index.html","hash":"1c08e15af278b2aa1d97e9a8b093c3c017367643","modified":1553951662553},{"_id":"public/archives/index.html","hash":"714a257e1f27b3a69fa689909cf830adee2d79c6","modified":1553951662553},{"_id":"public/archives/page/2/index.html","hash":"8a81d798620130b2feb37570fd705f468a3f0dfc","modified":1553951662553},{"_id":"public/archives/2018/index.html","hash":"28048563f15b76122271ff99bb218196d3de59e8","modified":1553951662553},{"_id":"public/archives/2018/10/index.html","hash":"13620bca382eaa58f7278771c4790bb7cb3916a2","modified":1553951662553},{"_id":"public/archives/2019/index.html","hash":"d7589c99d7e877bbcea69d9726f4ccaf7295dabd","modified":1553951662553},{"_id":"public/archives/2018/11/index.html","hash":"7eb89f38097b838f62ff33f203a33715305329a9","modified":1553951662553},{"_id":"public/archives/2019/01/index.html","hash":"66e19bd2c7127f7a16039336c203099e4722515a","modified":1553951662553},{"_id":"public/archives/2019/02/index.html","hash":"4eceb71c64803da87c8c0e5162c2abba73a04a78","modified":1553951662553},{"_id":"public/archives/2019/03/index.html","hash":"c9e6389ee1fb80d56c50e40b58a5d25437225775","modified":1553951662553},{"_id":"public/page/2/index.html","hash":"e94f6b3d7c5af815a4acf575316b4913ffc4838e","modified":1553951662553},{"_id":"public/tags/Vue-vscode/index.html","hash":"6a4436428af61adc0124b4938ce5c6f61a16d767","modified":1553951662553},{"_id":"public/tags/Vue/index.html","hash":"9ca128c21c5e7d6b6fb771e6b1da86c97c07ec3c","modified":1553951662553},{"_id":"public/tags/ES6/index.html","hash":"c578b00a017c872eba2eac7009a2e60cf167e0f6","modified":1553951662554},{"_id":"public/undefined/2019-01-29-ES2015中class基本语法/index.html","hash":"02cf74fbde05c1db4b58196ca8740abf7a09c3cd","modified":1553951662554},{"_id":"public/undefined/2019-01-01-Vue中使用scss和sass语法/index.html","hash":"01b2611128c4849acd3083c0d18a10cd8c801dd9","modified":1553951662554},{"_id":"public/undefined/2019-01-01-Vue中使用px2rem把px转换为rem/index.html","hash":"e63d492e27f9fb4a8138e01c03d6010694fd2664","modified":1553951662554},{"_id":"public/index.html","hash":"90730836e7ce15a68b86bd89f99ff597496a5911","modified":1553951662554},{"_id":"public/favicon.ico","hash":"e2a9e90adda6b803a273bfadaf23b47c584fd5e1","modified":1553951662559},{"_id":"public/images/favicon.ico","hash":"cc7c201861748e92f4809507096df74a40ef496a","modified":1553951662559},{"_id":"public/images/touch-icon.png","hash":"df5a490c2e8d549ca767505fbe46eed3cbe3df43","modified":1553951662559},{"_id":"public/images/alipay.png","hash":"d58434f2543e983ecb2e2240d92bdc825e40fa60","modified":1553951662559},{"_id":"public/images/wechat.png","hash":"4742a2f020b5be1d9b12681faaeace8a7c91c570","modified":1553951662559},{"_id":"public/styles/global.scss","hash":"e57778be87e9e750c3de5406e361cac85d5f07c3","modified":1553951662559},{"_id":"public/styles/index.scss","hash":"157f920a729437f0d3599d73bc211935e7d942c7","modified":1553951662559},{"_id":"public/styles/components/bottom-bar.scss","hash":"f000e077744775c12c278af3b3b5200445a46370","modified":1553951662559},{"_id":"public/styles/components/comment.scss","hash":"1b9621b1d70c715a694d28517987e73bf2784d1a","modified":1553951662559},{"_id":"public/styles/components/index.scss","hash":"59a07eb2af79a13b2d0ffed99f6a9f73d7d4dc51","modified":1553951662560},{"_id":"public/styles/components/layer.scss","hash":"c65d4eba57c3332bb72257e949df1f2e02376c11","modified":1553951662560},{"_id":"public/styles/components/share.scss","hash":"82907f1f237eba3ac6ac33cf0208fc8fce8a52c5","modified":1553951662560},{"_id":"public/styles/components/toc.scss","hash":"4d724a87b55edca2c124f107550a2a0852eb301e","modified":1553951662560},{"_id":"public/styles/layout/about.scss","hash":"5653765541ecab79cf22099d12b33bb43cd1df9f","modified":1553951662560},{"_id":"public/styles/layout/friend.scss","hash":"6e0a87d8cf670946df1a9bc58183dc2cf455d3b8","modified":1553951662560},{"_id":"public/styles/layout/home.scss","hash":"74377081d7065bb2f9819463bbcebd719a5423bf","modified":1553951662560},{"_id":"public/styles/layout/index.scss","hash":"1b3c2e2c3ad6d838e6486b5dfacc7b68ebbebb94","modified":1553951662560},{"_id":"public/styles/layout/set.scss","hash":"ed99c8ff9778815dd15d8649676957c893b0ecf2","modified":1553951662560},{"_id":"public/styles/layout/passage.scss","hash":"0d2550448537c73c81c934c243ac391ec193b59f","modified":1553951662560},{"_id":"public/styles/layout/timeline.scss","hash":"e4b7d6ce2508e986faf2e8cc4c3d975ffb096e92","modified":1553951662560},{"_id":"public/styles/mixins/color.scss","hash":"fc9b234fd5a55167ee6df0d15b620af987584be5","modified":1553951662560},{"_id":"public/styles/mixins/font.scss","hash":"4e3320626526b26cb9a95043cc3cad3c4b0ac17d","modified":1553951662560},{"_id":"public/styles/mixins/index.scss","hash":"0a92b657aeb5d176501bb2dc5a9b2d4137f23192","modified":1553951662560},{"_id":"public/styles/partials/footer.scss","hash":"3c664b6e9dae7f9c70faffa6884bc8109254b020","modified":1553951662560},{"_id":"public/styles/partials/header.scss","hash":"66dbe05cff7ca389ba33617fbed33ca77b20c6ef","modified":1553951662561},{"_id":"public/styles/partials/index.scss","hash":"40d727b8b464e174a1f0fa2da16aa28ce7792cc7","modified":1553951662561},{"_id":"public/js/backTop.js","hash":"237a50a872e2fe8343353bbe18fabb3c1681f0d0","modified":1553951662700},{"_id":"public/js/auth.js","hash":"94508e5db3ea64f5a913ccfb05e04ecf51361395","modified":1553951662699},{"_id":"public/js/header.js","hash":"c758cb821ed923f45fae608d333c6935adc38f3d","modified":1553951662700},{"_id":"public/js/copy.js","hash":"902fe6c84d2ebbfb37e1f91f37646bea20db8c05","modified":1553951662700},{"_id":"public/js/index.js","hash":"2575e6a1cd7d30e006862bedbefc034220401da0","modified":1553951662700},{"_id":"public/js/layer.js","hash":"dc17348c7bef8a78f9a258d2f25864853ee4a576","modified":1553951662700},{"_id":"public/js/leancloud.js","hash":"e91b45003ab747ca9162f83d033a572b00c86be5","modified":1553951662700},{"_id":"public/js/mathjax.js","hash":"3c58ffe041c6e124c5d927d0e7127659b562cfd8","modified":1553951662700},{"_id":"public/js/passage.js","hash":"cff41ceccdeefb44473d0b928c8c7f695502896a","modified":1553951662700},{"_id":"public/js/reward.js","hash":"6b7cec619073de3380a7e3d0b4f96f6c22db93d4","modified":1553951662700},{"_id":"public/js/scroll.js","hash":"938dd852f6ac214f8ad0135fce7a8b126c36ef7c","modified":1553951662700},{"_id":"public/js/share.js","hash":"4fcb58fe1d5332cb59f3d559401231ba8106ee2b","modified":1553951662700},{"_id":"public/js/time.js","hash":"4b86b54eea0bbdd8870af6c70443b852393c457b","modified":1553951662700},{"_id":"public/vendor/sha256.min.js","hash":"3c5ff30e1f6d37786a336c407defaf5bb7bb258a","modified":1553951662700},{"_id":"public/styles/components/highlight/diff.css","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1553951662700},{"_id":"public/styles/components/highlight/highlight.css","hash":"ee9a7e3f39fb6a0ae47943d2ea958674619ff47c","modified":1553951662700},{"_id":"public/styles/components/highlight/theme.css","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1553951662701},{"_id":"public/styles/components/highlight/var.css","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1553951662701},{"_id":"public/css/index.css","hash":"1b26e6c669581e76df2337062f0c13d3a4c97d23","modified":1553951662701},{"_id":"public/vendor/qrcode.min.js","hash":"2d06c1f823f34c19981c6ae0b0eb0f5861c5e14b","modified":1553951662701}],"Category":[],"Data":[],"Page":[{"_content":"<!DOCTYPE HTML>\n<html>\n\n<head>\n    <meta http-equiv=\"content-type\" content=\"text/html;charset=utf-8;\" />\n    <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge,chrome=1\" />\n    <meta name=\"robots\" content=\"all\" />\n    <meta name=\"robots\" content=\"index,follow\" />\n    <link rel=\"stylesheet\" type=\"text/css\" href=\"https://qzone.qq.com/gy/404/style/404style.css\">\n</head>\n\n<body>\n    <script type=\"text/plain\" src=\"http://www.qq.com/404/search_children.js\" charset=\"utf-8\" homePageUrl=\"/\"\n        homePageName=\"回到我的主页\">\n    </script>\n    <script src=\"https://qzone.qq.com/gy/404/data.js\" charset=\"utf-8\"></script>\n    <script src=\"https://qzone.qq.com/gy/404/page.js\" charset=\"utf-8\"></script>\n</body>\n\n</html>","source":"404.html","raw":"<!DOCTYPE HTML>\n<html>\n\n<head>\n    <meta http-equiv=\"content-type\" content=\"text/html;charset=utf-8;\" />\n    <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge,chrome=1\" />\n    <meta name=\"robots\" content=\"all\" />\n    <meta name=\"robots\" content=\"index,follow\" />\n    <link rel=\"stylesheet\" type=\"text/css\" href=\"https://qzone.qq.com/gy/404/style/404style.css\">\n</head>\n\n<body>\n    <script type=\"text/plain\" src=\"http://www.qq.com/404/search_children.js\" charset=\"utf-8\" homePageUrl=\"/\"\n        homePageName=\"回到我的主页\">\n    </script>\n    <script src=\"https://qzone.qq.com/gy/404/data.js\" charset=\"utf-8\"></script>\n    <script src=\"https://qzone.qq.com/gy/404/page.js\" charset=\"utf-8\"></script>\n</body>\n\n</html>","date":"2018-10-07T07:15:04.380Z","updated":"2018-10-06T15:24:49.819Z","path":"404.html","title":"","comments":1,"layout":"page","_id":"cjtviomv00000btzicxmx2qwa","content":"<!DOCTYPE HTML>\n<html>\n\n<head>\n    <meta http-equiv=\"content-type\" content=\"text/html;charset=utf-8;\">\n    <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge,chrome=1\">\n    <meta name=\"robots\" content=\"all\">\n    <meta name=\"robots\" content=\"index,follow\">\n    <link rel=\"stylesheet\" type=\"text/css\" href=\"https://qzone.qq.com/gy/404/style/404style.css\">\n</head>\n\n<body>\n    <script type=\"text/plain\" src=\"http://www.qq.com/404/search_children.js\" charset=\"utf-8\" homepageurl=\"/\" homepagename=\"回到我的主页\">\n    </script>\n    <script src=\"https://qzone.qq.com/gy/404/data.js\" charset=\"utf-8\"></script>\n    <script src=\"https://qzone.qq.com/gy/404/page.js\" charset=\"utf-8\"></script>\n</body>\n\n</html>","site":{"data":{}},"excerpt":"","more":"<!DOCTYPE HTML>\n<html>\n\n<head>\n    <meta http-equiv=\"content-type\" content=\"text/html;charset=utf-8;\">\n    <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge,chrome=1\">\n    <meta name=\"robots\" content=\"all\">\n    <meta name=\"robots\" content=\"index,follow\">\n    <link rel=\"stylesheet\" type=\"text/css\" href=\"https://qzone.qq.com/gy/404/style/404style.css\">\n</head>\n\n<body>\n    <script type=\"text/plain\" src=\"http://www.qq.com/404/search_children.js\" charset=\"utf-8\" homepageurl=\"/\" homepagename=\"回到我的主页\">\n    </script>\n    <script src=\"https://qzone.qq.com/gy/404/data.js\" charset=\"utf-8\"></script>\n    <script src=\"https://qzone.qq.com/gy/404/page.js\" charset=\"utf-8\"></script>\n</body>\n\n</html>"},{"title":"about","date":"2019-03-30T12:57:17.000Z","type":"about","_content":"\n## 姓名：尹盛（semyin）\n## 坐标：深圳（shenzhen）\n## 职位：web前端开发（web developer）\n## 公司：深圳灵钛科技有限公司（linktime）\n## 关于我自己：二次元，懒癌晚期，喜欢结交朋友。\n","source":"about/index.md","raw":"---\ntitle: about\ndate: 2019-03-30 20:57:17\ntype: 'about'\n---\n\n## 姓名：尹盛（semyin）\n## 坐标：深圳（shenzhen）\n## 职位：web前端开发（web developer）\n## 公司：深圳灵钛科技有限公司（linktime）\n## 关于我自己：二次元，懒癌晚期，喜欢结交朋友。\n","updated":"2019-03-30T13:00:55.325Z","path":"about/index.html","comments":1,"layout":"page","_id":"cjtviomvz0002btzip2ukw503","content":"<h2 id=\"姓名：尹盛（semyin）\"><a href=\"#姓名：尹盛（semyin）\" class=\"headerlink\" title=\"姓名：尹盛（semyin）\"></a>姓名：尹盛（semyin）</h2><h2 id=\"坐标：深圳（shenzhen）\"><a href=\"#坐标：深圳（shenzhen）\" class=\"headerlink\" title=\"坐标：深圳（shenzhen）\"></a>坐标：深圳（shenzhen）</h2><h2 id=\"职位：web前端开发（web-developer）\"><a href=\"#职位：web前端开发（web-developer）\" class=\"headerlink\" title=\"职位：web前端开发（web developer）\"></a>职位：web前端开发（web developer）</h2><h2 id=\"公司：深圳灵钛科技有限公司（linktime）\"><a href=\"#公司：深圳灵钛科技有限公司（linktime）\" class=\"headerlink\" title=\"公司：深圳灵钛科技有限公司（linktime）\"></a>公司：深圳灵钛科技有限公司（linktime）</h2><h2 id=\"关于我自己：二次元，懒癌晚期，喜欢结交朋友。\"><a href=\"#关于我自己：二次元，懒癌晚期，喜欢结交朋友。\" class=\"headerlink\" title=\"关于我自己：二次元，懒癌晚期，喜欢结交朋友。\"></a>关于我自己：二次元，懒癌晚期，喜欢结交朋友。</h2>","site":{"data":{}},"excerpt":"","more":"<h2 id=\"姓名：尹盛（semyin）\"><a href=\"#姓名：尹盛（semyin）\" class=\"headerlink\" title=\"姓名：尹盛（semyin）\"></a>姓名：尹盛（semyin）</h2><h2 id=\"坐标：深圳（shenzhen）\"><a href=\"#坐标：深圳（shenzhen）\" class=\"headerlink\" title=\"坐标：深圳（shenzhen）\"></a>坐标：深圳（shenzhen）</h2><h2 id=\"职位：web前端开发（web-developer）\"><a href=\"#职位：web前端开发（web-developer）\" class=\"headerlink\" title=\"职位：web前端开发（web developer）\"></a>职位：web前端开发（web developer）</h2><h2 id=\"公司：深圳灵钛科技有限公司（linktime）\"><a href=\"#公司：深圳灵钛科技有限公司（linktime）\" class=\"headerlink\" title=\"公司：深圳灵钛科技有限公司（linktime）\"></a>公司：深圳灵钛科技有限公司（linktime）</h2><h2 id=\"关于我自己：二次元，懒癌晚期，喜欢结交朋友。\"><a href=\"#关于我自己：二次元，懒癌晚期，喜欢结交朋友。\" class=\"headerlink\" title=\"关于我自己：二次元，懒癌晚期，喜欢结交朋友。\"></a>关于我自己：二次元，懒癌晚期，喜欢结交朋友。</h2>"},{"title":"分类","date":"2018-10-06T08:22:59.000Z","type":"categories","_content":"","source":"categories/index.md","raw":"---\ntitle: 分类\ndate: 2018-10-06 16:22:59\ntype: \"categories\"\n---\n","updated":"2018-10-06T08:24:08.999Z","path":"categories/index.html","comments":1,"layout":"page","_id":"cjtviomwu000rbtzib8ifsm59","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"标签","date":"2018-10-06T08:17:03.000Z","type":"tags","_content":"","source":"tags/index.md","raw":"---\ntitle: 标签\ndate: 2018-10-06 16:17:03\ntype: \"tags\"\n---\n","updated":"2018-10-06T08:24:09.000Z","path":"tags/index.html","comments":1,"layout":"page","_id":"cjtviomwu000sbtzit34iamb6","content":"","site":{"data":{}},"excerpt":"","more":""}],"Post":[{"title":"vscode下.vue文件初始化","date":"2018-10-06T08:38:53.000Z","_content":"\n## vscode下.vue文件初始化\n当我们在使用vscode编写vue文件的时候，每次都需要输入`<template></template>`,`<script></script>`,`<style></style>`这些标签  \n如何像我们之前一样写html使用emmet插件一样使用 `!`自动出来html的格式呢\n<!-- more -->\n### 1 安装Vetur扩展让VScode支持.vue文件名\n### 2 然后打开 菜单栏=>Code=>首选项=>用户代码片段=>选择vue\n### 3 打开后发现是一个json文件，里面都是注释，不用管它，我们再后面添加\n```JavaScript\n\"Vue Init\":{\n        \"prefix\": \"vue\",\n        \"description\": \"初始化Vue单文件组件模板\",\n        \"body\": [\n            \"<template>\",\n            \"$1\",\n            \"</template>\",\n            \"<script>\",\n            \"export default {\",\n            \"   name:'$2',\",\n            \"}\",\n            \"</script>\",\n            \"<style scoped>\",\n            \"$3\",\n            \"</style>\",\n            \"\"\n        ]\n    }\n```\n### 4 新建任一一个vue文件，第一行输入`vue`，会弹出来以下提示，按enter就ok了\n![](/images/blog-img/18-10-7/1.png'描述')\n<img src=\"/images/blog-img/18-10-7/1.png\">\n","source":"_posts/2018-10-06-vscode下-vue文件初始化.md","raw":"---\ntitle: vscode下.vue文件初始化\ndate: 2018-10-06 16:38:53\ntags:\n    -Vue\n    -vscode\ncategories:\n---\n\n## vscode下.vue文件初始化\n当我们在使用vscode编写vue文件的时候，每次都需要输入`<template></template>`,`<script></script>`,`<style></style>`这些标签  \n如何像我们之前一样写html使用emmet插件一样使用 `!`自动出来html的格式呢\n<!-- more -->\n### 1 安装Vetur扩展让VScode支持.vue文件名\n### 2 然后打开 菜单栏=>Code=>首选项=>用户代码片段=>选择vue\n### 3 打开后发现是一个json文件，里面都是注释，不用管它，我们再后面添加\n```JavaScript\n\"Vue Init\":{\n        \"prefix\": \"vue\",\n        \"description\": \"初始化Vue单文件组件模板\",\n        \"body\": [\n            \"<template>\",\n            \"$1\",\n            \"</template>\",\n            \"<script>\",\n            \"export default {\",\n            \"   name:'$2',\",\n            \"}\",\n            \"</script>\",\n            \"<style scoped>\",\n            \"$3\",\n            \"</style>\",\n            \"\"\n        ]\n    }\n```\n### 4 新建任一一个vue文件，第一行输入`vue`，会弹出来以下提示，按enter就ok了\n![](/images/blog-img/18-10-7/1.png'描述')\n<img src=\"/images/blog-img/18-10-7/1.png\">\n","slug":"2018-10-06-vscode下-vue文件初始化","published":1,"updated":"2019-03-05T14:53:37.175Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjtviomvw0001btzir2pme5iu","content":"<h2 id=\"vscode下-vue文件初始化\"><a href=\"#vscode下-vue文件初始化\" class=\"headerlink\" title=\"vscode下.vue文件初始化\"></a>vscode下.vue文件初始化</h2><p>当我们在使用vscode编写vue文件的时候，每次都需要输入<code>&lt;template&gt;&lt;/template&gt;</code>,<code>&lt;script&gt;&lt;/script&gt;</code>,<code>&lt;style&gt;&lt;/style&gt;</code>这些标签<br>如何像我们之前一样写html使用emmet插件一样使用 <code>!</code>自动出来html的格式呢<br><a id=\"more\"></a></p>\n<h3 id=\"1-安装Vetur扩展让VScode支持-vue文件名\"><a href=\"#1-安装Vetur扩展让VScode支持-vue文件名\" class=\"headerlink\" title=\"1 安装Vetur扩展让VScode支持.vue文件名\"></a>1 安装Vetur扩展让VScode支持.vue文件名</h3><h3 id=\"2-然后打开-菜单栏-gt-Code-gt-首选项-gt-用户代码片段-gt-选择vue\"><a href=\"#2-然后打开-菜单栏-gt-Code-gt-首选项-gt-用户代码片段-gt-选择vue\" class=\"headerlink\" title=\"2 然后打开 菜单栏=&gt;Code=&gt;首选项=&gt;用户代码片段=&gt;选择vue\"></a>2 然后打开 菜单栏=&gt;Code=&gt;首选项=&gt;用户代码片段=&gt;选择vue</h3><h3 id=\"3-打开后发现是一个json文件，里面都是注释，不用管它，我们再后面添加\"><a href=\"#3-打开后发现是一个json文件，里面都是注释，不用管它，我们再后面添加\" class=\"headerlink\" title=\"3 打开后发现是一个json文件，里面都是注释，不用管它，我们再后面添加\"></a>3 打开后发现是一个json文件，里面都是注释，不用管它，我们再后面添加</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"string\">\"Vue Init\"</span>:&#123;</span><br><span class=\"line\">        <span class=\"string\">\"prefix\"</span>: <span class=\"string\">\"vue\"</span>,</span><br><span class=\"line\">        <span class=\"string\">\"description\"</span>: <span class=\"string\">\"初始化Vue单文件组件模板\"</span>,</span><br><span class=\"line\">        <span class=\"string\">\"body\"</span>: [</span><br><span class=\"line\">            <span class=\"string\">\"&lt;template&gt;\"</span>,</span><br><span class=\"line\">            <span class=\"string\">\"$1\"</span>,</span><br><span class=\"line\">            <span class=\"string\">\"&lt;/template&gt;\"</span>,</span><br><span class=\"line\">            <span class=\"string\">\"&lt;script&gt;\"</span>,</span><br><span class=\"line\">            <span class=\"string\">\"export default &#123;\"</span>,</span><br><span class=\"line\">            <span class=\"string\">\"   name:'$2',\"</span>,</span><br><span class=\"line\">            <span class=\"string\">\"&#125;\"</span>,</span><br><span class=\"line\">            <span class=\"string\">\"&lt;/script&gt;\"</span>,</span><br><span class=\"line\">            <span class=\"string\">\"&lt;style scoped&gt;\"</span>,</span><br><span class=\"line\">            <span class=\"string\">\"$3\"</span>,</span><br><span class=\"line\">            <span class=\"string\">\"&lt;/style&gt;\"</span>,</span><br><span class=\"line\">            <span class=\"string\">\"\"</span></span><br><span class=\"line\">        ]</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"4-新建任一一个vue文件，第一行输入vue，会弹出来以下提示，按enter就ok了\"><a href=\"#4-新建任一一个vue文件，第一行输入vue，会弹出来以下提示，按enter就ok了\" class=\"headerlink\" title=\"4 新建任一一个vue文件，第一行输入vue，会弹出来以下提示，按enter就ok了\"></a>4 新建任一一个vue文件，第一行输入<code>vue</code>，会弹出来以下提示，按enter就ok了</h3><p><img src=\"/images/blog-img/18-10-7/1.png&#39;描述&#39;\" alt=\"\"><br><img src=\"/images/blog-img/18-10-7/1.png\"></p>\n","site":{"data":{}},"excerpt":"<h2 id=\"vscode下-vue文件初始化\"><a href=\"#vscode下-vue文件初始化\" class=\"headerlink\" title=\"vscode下.vue文件初始化\"></a>vscode下.vue文件初始化</h2><p>当我们在使用vscode编写vue文件的时候，每次都需要输入<code>&lt;template&gt;&lt;/template&gt;</code>,<code>&lt;script&gt;&lt;/script&gt;</code>,<code>&lt;style&gt;&lt;/style&gt;</code>这些标签<br>如何像我们之前一样写html使用emmet插件一样使用 <code>!</code>自动出来html的格式呢<br>","more":"</p>\n<h3 id=\"1-安装Vetur扩展让VScode支持-vue文件名\"><a href=\"#1-安装Vetur扩展让VScode支持-vue文件名\" class=\"headerlink\" title=\"1 安装Vetur扩展让VScode支持.vue文件名\"></a>1 安装Vetur扩展让VScode支持.vue文件名</h3><h3 id=\"2-然后打开-菜单栏-gt-Code-gt-首选项-gt-用户代码片段-gt-选择vue\"><a href=\"#2-然后打开-菜单栏-gt-Code-gt-首选项-gt-用户代码片段-gt-选择vue\" class=\"headerlink\" title=\"2 然后打开 菜单栏=&gt;Code=&gt;首选项=&gt;用户代码片段=&gt;选择vue\"></a>2 然后打开 菜单栏=&gt;Code=&gt;首选项=&gt;用户代码片段=&gt;选择vue</h3><h3 id=\"3-打开后发现是一个json文件，里面都是注释，不用管它，我们再后面添加\"><a href=\"#3-打开后发现是一个json文件，里面都是注释，不用管它，我们再后面添加\" class=\"headerlink\" title=\"3 打开后发现是一个json文件，里面都是注释，不用管它，我们再后面添加\"></a>3 打开后发现是一个json文件，里面都是注释，不用管它，我们再后面添加</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"string\">\"Vue Init\"</span>:&#123;</span><br><span class=\"line\">        <span class=\"string\">\"prefix\"</span>: <span class=\"string\">\"vue\"</span>,</span><br><span class=\"line\">        <span class=\"string\">\"description\"</span>: <span class=\"string\">\"初始化Vue单文件组件模板\"</span>,</span><br><span class=\"line\">        <span class=\"string\">\"body\"</span>: [</span><br><span class=\"line\">            <span class=\"string\">\"&lt;template&gt;\"</span>,</span><br><span class=\"line\">            <span class=\"string\">\"$1\"</span>,</span><br><span class=\"line\">            <span class=\"string\">\"&lt;/template&gt;\"</span>,</span><br><span class=\"line\">            <span class=\"string\">\"&lt;script&gt;\"</span>,</span><br><span class=\"line\">            <span class=\"string\">\"export default &#123;\"</span>,</span><br><span class=\"line\">            <span class=\"string\">\"   name:'$2',\"</span>,</span><br><span class=\"line\">            <span class=\"string\">\"&#125;\"</span>,</span><br><span class=\"line\">            <span class=\"string\">\"&lt;/script&gt;\"</span>,</span><br><span class=\"line\">            <span class=\"string\">\"&lt;style scoped&gt;\"</span>,</span><br><span class=\"line\">            <span class=\"string\">\"$3\"</span>,</span><br><span class=\"line\">            <span class=\"string\">\"&lt;/style&gt;\"</span>,</span><br><span class=\"line\">            <span class=\"string\">\"\"</span></span><br><span class=\"line\">        ]</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"4-新建任一一个vue文件，第一行输入vue，会弹出来以下提示，按enter就ok了\"><a href=\"#4-新建任一一个vue文件，第一行输入vue，会弹出来以下提示，按enter就ok了\" class=\"headerlink\" title=\"4 新建任一一个vue文件，第一行输入vue，会弹出来以下提示，按enter就ok了\"></a>4 新建任一一个vue文件，第一行输入<code>vue</code>，会弹出来以下提示，按enter就ok了</h3><p><img src=\"/images/blog-img/18-10-7/1.png&#39;描述&#39;\" alt=\"\"><br><img src=\"/images/blog-img/18-10-7/1.png\"></p>"},{"title":"vscode格式化vue文件","date":"2018-10-06T08:06:04.000Z","_content":"\n##  使用VScode格式化.vue文件\n首先在应用商店搜索“Vetur”插件安装，然后进行下面的操作：\n>{  \n    \"prettier.tabWidth\":4,  \n    \"Vetur.format.defaultFormatter.html\":\"prettiers\"  \n}","source":"_posts/2018-10-06-vscode格式化vue文件.md","raw":"---\ntitle: vscode格式化vue文件\ndate: 2018-10-06 16:06:04\ntags:\n    -Vue\ncategories:\n---\n\n##  使用VScode格式化.vue文件\n首先在应用商店搜索“Vetur”插件安装，然后进行下面的操作：\n>{  \n    \"prettier.tabWidth\":4,  \n    \"Vetur.format.defaultFormatter.html\":\"prettiers\"  \n}","slug":"2018-10-06-vscode格式化vue文件","published":1,"updated":"2019-03-05T14:53:50.054Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjtviomw00003btzimhz6ylta","content":"<h2 id=\"使用VScode格式化-vue文件\"><a href=\"#使用VScode格式化-vue文件\" class=\"headerlink\" title=\"使用VScode格式化.vue文件\"></a>使用VScode格式化.vue文件</h2><p>首先在应用商店搜索“Vetur”插件安装，然后进行下面的操作：</p>\n<blockquote>\n<p>{<br>    “prettier.tabWidth”:4,<br>    “Vetur.format.defaultFormatter.html”:”prettiers”<br>}</p>\n</blockquote>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"使用VScode格式化-vue文件\"><a href=\"#使用VScode格式化-vue文件\" class=\"headerlink\" title=\"使用VScode格式化.vue文件\"></a>使用VScode格式化.vue文件</h2><p>首先在应用商店搜索“Vetur”插件安装，然后进行下面的操作：</p>\n<blockquote>\n<p>{<br>    “prettier.tabWidth”:4,<br>    “Vetur.format.defaultFormatter.html”:”prettiers”<br>}</p>\n</blockquote>\n"},{"title":"Vue在安卓低版本兼容问题","date":"2018-11-03T07:44:57.000Z","_content":"\n## Vue在安卓低版本的兼容问题\n在弄公司的项目的时候\b，打包完部署到测试环境上，发现有的低版本安卓有些样式不兼容，\b甚至有些数据请求不出来。\n\n网上查了一些方法，现在列出来：\n### 1.npm 安装 `bable-polyfill` `es6-promise`\n>\n    npm install babel-polyfill  \n    npm install es6-promise\n\n### 2.安装完在项目\b根目录会出现：\n\n>\n    \"bable-polyfill\":\"^6.xxx\",\n    \"es6-promise\":\"^4.xxx\"\n\n### 3.在项目入口文件`main.js`引入下面这段代码：\n\n```Javascript\n    \"import 'bable-polyfill\"\n    \"import 'es6-promise\"\n```\n\n### 4.在`build`文件下的`webpack.base.conf.js`添加下面一段\n\n```Javascript\n    module.exports = {\n        context: path.resolve(__dirname,'../'),\n        entry:{\n            // app:'./src/main.js'  //原来的注释掉 \b换成下面的\n            app:[\"babel-polyfill\",\"./src/main.js\"]\n        }\n    }\n```\n### 5.重新打包部署\b，就可以支持低版本的安卓，我测试最低的支持5.0","source":"_posts/2018-11-03-Vue在安卓低版本兼容问题.md","raw":"---\ntitle: Vue在安卓低版本兼容问题\ndate: 2018-11-03 15:44:57\ntags: \n    -Vue\n---\n\n## Vue在安卓低版本的兼容问题\n在弄公司的项目的时候\b，打包完部署到测试环境上，发现有的低版本安卓有些样式不兼容，\b甚至有些数据请求不出来。\n\n网上查了一些方法，现在列出来：\n### 1.npm 安装 `bable-polyfill` `es6-promise`\n>\n    npm install babel-polyfill  \n    npm install es6-promise\n\n### 2.安装完在项目\b根目录会出现：\n\n>\n    \"bable-polyfill\":\"^6.xxx\",\n    \"es6-promise\":\"^4.xxx\"\n\n### 3.在项目入口文件`main.js`引入下面这段代码：\n\n```Javascript\n    \"import 'bable-polyfill\"\n    \"import 'es6-promise\"\n```\n\n### 4.在`build`文件下的`webpack.base.conf.js`添加下面一段\n\n```Javascript\n    module.exports = {\n        context: path.resolve(__dirname,'../'),\n        entry:{\n            // app:'./src/main.js'  //原来的注释掉 \b换成下面的\n            app:[\"babel-polyfill\",\"./src/main.js\"]\n        }\n    }\n```\n### 5.重新打包部署\b，就可以支持低版本的安卓，我测试最低的支持5.0","slug":"2018-11-03-Vue在安卓低版本兼容问题","published":1,"updated":"2019-03-05T14:54:30.311Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjtviomw40005btziu2gc3cn9","content":"<h2 id=\"Vue在安卓低版本的兼容问题\"><a href=\"#Vue在安卓低版本的兼容问题\" class=\"headerlink\" title=\"Vue在安卓低版本的兼容问题\"></a>Vue在安卓低版本的兼容问题</h2><p>在弄公司的项目的时候\b，打包完部署到测试环境上，发现有的低版本安卓有些样式不兼容，\b甚至有些数据请求不出来。</p>\n<p>网上查了一些方法，现在列出来：</p>\n<h3 id=\"1-npm-安装-bable-polyfill-es6-promise\"><a href=\"#1-npm-安装-bable-polyfill-es6-promise\" class=\"headerlink\" title=\"1.npm 安装 bable-polyfill es6-promise\"></a>1.npm 安装 <code>bable-polyfill</code> <code>es6-promise</code></h3><blockquote>\n</blockquote>\n<pre><code>npm install babel-polyfill  \nnpm install es6-promise\n</code></pre><h3 id=\"2-安装完在项目根目录会出现：\"><a href=\"#2-安装完在项目根目录会出现：\" class=\"headerlink\" title=\"2.安装完在项目\b根目录会出现：\"></a>2.安装完在项目\b根目录会出现：</h3><blockquote>\n</blockquote>\n<pre><code>&quot;bable-polyfill&quot;:&quot;^6.xxx&quot;,\n&quot;es6-promise&quot;:&quot;^4.xxx&quot;\n</code></pre><h3 id=\"3-在项目入口文件main-js引入下面这段代码：\"><a href=\"#3-在项目入口文件main-js引入下面这段代码：\" class=\"headerlink\" title=\"3.在项目入口文件main.js引入下面这段代码：\"></a>3.在项目入口文件<code>main.js</code>引入下面这段代码：</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"string\">\"import 'bable-polyfill\"</span></span><br><span class=\"line\"><span class=\"string\">\"import 'es6-promise\"</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"4-在build文件下的webpack-base-conf-js添加下面一段\"><a href=\"#4-在build文件下的webpack-base-conf-js添加下面一段\" class=\"headerlink\" title=\"4.在build文件下的webpack.base.conf.js添加下面一段\"></a>4.在<code>build</code>文件下的<code>webpack.base.conf.js</code>添加下面一段</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">module</span>.exports = &#123;</span><br><span class=\"line\">    context: path.resolve(__dirname,<span class=\"string\">'../'</span>),</span><br><span class=\"line\">    entry:&#123;</span><br><span class=\"line\">        <span class=\"comment\">// app:'./src/main.js'  //原来的注释掉 \b换成下面的</span></span><br><span class=\"line\">        app:[<span class=\"string\">\"babel-polyfill\"</span>,<span class=\"string\">\"./src/main.js\"</span>]</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"5-重新打包部署，就可以支持低版本的安卓，我测试最低的支持5-0\"><a href=\"#5-重新打包部署，就可以支持低版本的安卓，我测试最低的支持5-0\" class=\"headerlink\" title=\"5.重新打包部署\b，就可以支持低版本的安卓，我测试最低的支持5.0\"></a>5.重新打包部署\b，就可以支持低版本的安卓，我测试最低的支持5.0</h3>","site":{"data":{}},"excerpt":"","more":"<h2 id=\"Vue在安卓低版本的兼容问题\"><a href=\"#Vue在安卓低版本的兼容问题\" class=\"headerlink\" title=\"Vue在安卓低版本的兼容问题\"></a>Vue在安卓低版本的兼容问题</h2><p>在弄公司的项目的时候\b，打包完部署到测试环境上，发现有的低版本安卓有些样式不兼容，\b甚至有些数据请求不出来。</p>\n<p>网上查了一些方法，现在列出来：</p>\n<h3 id=\"1-npm-安装-bable-polyfill-es6-promise\"><a href=\"#1-npm-安装-bable-polyfill-es6-promise\" class=\"headerlink\" title=\"1.npm 安装 bable-polyfill es6-promise\"></a>1.npm 安装 <code>bable-polyfill</code> <code>es6-promise</code></h3><blockquote>\n</blockquote>\n<pre><code>npm install babel-polyfill  \nnpm install es6-promise\n</code></pre><h3 id=\"2-安装完在项目根目录会出现：\"><a href=\"#2-安装完在项目根目录会出现：\" class=\"headerlink\" title=\"2.安装完在项目\b根目录会出现：\"></a>2.安装完在项目\b根目录会出现：</h3><blockquote>\n</blockquote>\n<pre><code>&quot;bable-polyfill&quot;:&quot;^6.xxx&quot;,\n&quot;es6-promise&quot;:&quot;^4.xxx&quot;\n</code></pre><h3 id=\"3-在项目入口文件main-js引入下面这段代码：\"><a href=\"#3-在项目入口文件main-js引入下面这段代码：\" class=\"headerlink\" title=\"3.在项目入口文件main.js引入下面这段代码：\"></a>3.在项目入口文件<code>main.js</code>引入下面这段代码：</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"string\">\"import 'bable-polyfill\"</span></span><br><span class=\"line\"><span class=\"string\">\"import 'es6-promise\"</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"4-在build文件下的webpack-base-conf-js添加下面一段\"><a href=\"#4-在build文件下的webpack-base-conf-js添加下面一段\" class=\"headerlink\" title=\"4.在build文件下的webpack.base.conf.js添加下面一段\"></a>4.在<code>build</code>文件下的<code>webpack.base.conf.js</code>添加下面一段</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">module</span>.exports = &#123;</span><br><span class=\"line\">    context: path.resolve(__dirname,<span class=\"string\">'../'</span>),</span><br><span class=\"line\">    entry:&#123;</span><br><span class=\"line\">        <span class=\"comment\">// app:'./src/main.js'  //原来的注释掉 \b换成下面的</span></span><br><span class=\"line\">        app:[<span class=\"string\">\"babel-polyfill\"</span>,<span class=\"string\">\"./src/main.js\"</span>]</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"5-重新打包部署，就可以支持低版本的安卓，我测试最低的支持5-0\"><a href=\"#5-重新打包部署，就可以支持低版本的安卓，我测试最低的支持5-0\" class=\"headerlink\" title=\"5.重新打包部署\b，就可以支持低版本的安卓，我测试最低的支持5.0\"></a>5.重新打包部署\b，就可以支持低版本的安卓，我测试最低的支持5.0</h3>"},{"title":"Vue-cli创建项目的时候卡在下载谷歌驱动问题","date":"2018-11-03T08:13:15.000Z","_content":"\n## npm 安装chromedriver失败解决办法\n\n在使用Vue-cli新建一个Vue项目的时候，在做完一系列项目init的操作完之后  \n`npm install`有时会出现:\n```\nDownloading https://chromedriver.storage.googleapis.com/2.27/chromedriver_mac64.zip\nSaving to  /var/folders/7l/mhhqzhps0y59by7pf04nyx5r0000gn/T/chromedriver/chromedriver_mac64.zip\n```\n出现这个的时候，可能会一直卡在这里，什么也做不了，实际上项目的包已经安装好了  \n经分析发现，某些版本下，chromedriver 的 zip 文件 url 的响应是 302 跳转，而在 install.js 里使用的是 Node.js 内置的 http 对象的 get 方法无法处理 302 跳转的情况；而在另外一些情况下，则是因为 googleapis.com 被墙了，此时即使采用科学上网的方法也仍然无法获取文件。\n\n无论是上述哪种情况，可以使用下面的命令安装：\n\n>npm install chromedriver --chromedriver_cdnurl=http://cdn.npm.taobao.org/dist/chromedriver\n\n或者用cnpm安装包依赖\n\n文章来自:[segmentfault](https://segmentfault.com/a/1190000008310875)","source":"_posts/2018-11-03-Vue脚手架创建的时候卡在Download-https-chromedriver-storage.md","raw":"---\ntitle: 'Vue-cli创建项目的时候卡在下载谷歌驱动问题'\ndate: 2018-11-03 16:13:15\ntags:\n    -Vue\n---\n\n## npm 安装chromedriver失败解决办法\n\n在使用Vue-cli新建一个Vue项目的时候，在做完一系列项目init的操作完之后  \n`npm install`有时会出现:\n```\nDownloading https://chromedriver.storage.googleapis.com/2.27/chromedriver_mac64.zip\nSaving to  /var/folders/7l/mhhqzhps0y59by7pf04nyx5r0000gn/T/chromedriver/chromedriver_mac64.zip\n```\n出现这个的时候，可能会一直卡在这里，什么也做不了，实际上项目的包已经安装好了  \n经分析发现，某些版本下，chromedriver 的 zip 文件 url 的响应是 302 跳转，而在 install.js 里使用的是 Node.js 内置的 http 对象的 get 方法无法处理 302 跳转的情况；而在另外一些情况下，则是因为 googleapis.com 被墙了，此时即使采用科学上网的方法也仍然无法获取文件。\n\n无论是上述哪种情况，可以使用下面的命令安装：\n\n>npm install chromedriver --chromedriver_cdnurl=http://cdn.npm.taobao.org/dist/chromedriver\n\n或者用cnpm安装包依赖\n\n文章来自:[segmentfault](https://segmentfault.com/a/1190000008310875)","slug":"2018-11-03-Vue脚手架创建的时候卡在Download-https-chromedriver-storage","published":1,"updated":"2019-03-30T12:56:07.027Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjtviomw50006btzigtywtouv","content":"<h2 id=\"npm-安装chromedriver失败解决办法\"><a href=\"#npm-安装chromedriver失败解决办法\" class=\"headerlink\" title=\"npm 安装chromedriver失败解决办法\"></a>npm 安装chromedriver失败解决办法</h2><p>在使用Vue-cli新建一个Vue项目的时候，在做完一系列项目init的操作完之后<br><code>npm install</code>有时会出现:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Downloading https://chromedriver.storage.googleapis.com/2.27/chromedriver_mac64.zip</span><br><span class=\"line\">Saving to  /var/folders/7l/mhhqzhps0y59by7pf04nyx5r0000gn/T/chromedriver/chromedriver_mac64.zip</span><br></pre></td></tr></table></figure></p>\n<p>出现这个的时候，可能会一直卡在这里，什么也做不了，实际上项目的包已经安装好了<br>经分析发现，某些版本下，chromedriver 的 zip 文件 url 的响应是 302 跳转，而在 install.js 里使用的是 Node.js 内置的 http 对象的 get 方法无法处理 302 跳转的情况；而在另外一些情况下，则是因为 googleapis.com 被墙了，此时即使采用科学上网的方法也仍然无法获取文件。</p>\n<p>无论是上述哪种情况，可以使用下面的命令安装：</p>\n<blockquote>\n<p>npm install chromedriver –chromedriver_cdnurl=<a href=\"http://cdn.npm.taobao.org/dist/chromedriver\" target=\"_blank\" rel=\"noopener\">http://cdn.npm.taobao.org/dist/chromedriver</a></p>\n</blockquote>\n<p>或者用cnpm安装包依赖</p>\n<p>文章来自:<a href=\"https://segmentfault.com/a/1190000008310875\" target=\"_blank\" rel=\"noopener\">segmentfault</a></p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"npm-安装chromedriver失败解决办法\"><a href=\"#npm-安装chromedriver失败解决办法\" class=\"headerlink\" title=\"npm 安装chromedriver失败解决办法\"></a>npm 安装chromedriver失败解决办法</h2><p>在使用Vue-cli新建一个Vue项目的时候，在做完一系列项目init的操作完之后<br><code>npm install</code>有时会出现:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Downloading https://chromedriver.storage.googleapis.com/2.27/chromedriver_mac64.zip</span><br><span class=\"line\">Saving to  /var/folders/7l/mhhqzhps0y59by7pf04nyx5r0000gn/T/chromedriver/chromedriver_mac64.zip</span><br></pre></td></tr></table></figure></p>\n<p>出现这个的时候，可能会一直卡在这里，什么也做不了，实际上项目的包已经安装好了<br>经分析发现，某些版本下，chromedriver 的 zip 文件 url 的响应是 302 跳转，而在 install.js 里使用的是 Node.js 内置的 http 对象的 get 方法无法处理 302 跳转的情况；而在另外一些情况下，则是因为 googleapis.com 被墙了，此时即使采用科学上网的方法也仍然无法获取文件。</p>\n<p>无论是上述哪种情况，可以使用下面的命令安装：</p>\n<blockquote>\n<p>npm install chromedriver –chromedriver_cdnurl=<a href=\"http://cdn.npm.taobao.org/dist/chromedriver\" target=\"_blank\" rel=\"noopener\">http://cdn.npm.taobao.org/dist/chromedriver</a></p>\n</blockquote>\n<p>或者用cnpm安装包依赖</p>\n<p>文章来自:<a href=\"https://segmentfault.com/a/1190000008310875\" target=\"_blank\" rel=\"noopener\">segmentfault</a></p>\n"},{"title":"Vue中使用px2rem把px转换为rem","date":"2019-01-01T05:27:07.000Z","_content":"\n## Vue中使用px2rem把px转换为rem\n使用Vue做移动端页面时，适配是必须的，rem不失为一种好的选择，可在不同屏幕上完美显示相同的布局\npx2rem插件可以使`<style></style>`中的px单位根据设计稿转换为rem\n\n### 1.安装\n> npm install px2rem-loader -S\n\n### 2.配置`px2rem-loader`\n在`build/utils.js`的15行`export.assetsPath = function(_pth){...}`里面添加：\n\n```JavaScript\n    export.cssLoaders = funtion(options){\n        option = option || {}\n        const cssLoader = {\n            loader:'css-loader',\n            options:{\n                sourceMap:options.sourceMap\n            }\n        }\n        //\b下面为添加的代码\n        const px2RemLoader = {\n            loader:'px2rem-loader',\n            options:{\n                remUnit:75 //设计稿宽度的10%\n            }\n        }\n        const postcssLoader = {\n            loader:'postcss=loader',\n            options:{\n                sourceMap:options.sourceMap\n            }\n        }\n    }\n```\n### 3.修改`function generateLoader(loader,loaderOptions){...}`    \n将`const loader = ...`后面的三元运算符问好后面的数组每一个都加上`px2remLoader`\n```JavaScript\n    function generateLoaders(loader, loaderOptions){\n        const loaders = option.usePostCss ? [cssLoader, postcssLoader, px2remLoader] : [cssLoader, px2remLoader]\n\n        if(loader) {\n            ....\n        }\n    }\n```\n### 4.使用\n```html\n    <style lang=\"\" scoped>\n        .wrap{\n            width:750px; /** 上面的remUnit：75的时候为10rem **/\n            height:1334px\n        }\n    </style>\n```\n### 5.注意事项\n安装px2rem后，再使用px上有些不同，大家可以参考px2rem官方介绍，下面简单介绍一下。  \n1，直接写px，编译后会直接转化成rem ---- 除开下面两种情况，其他长度用这个  \n\n2，在px后面添加`/*no*/`，不会转化px，会原样输出。 --- 一般border需用这个    \n\n3，在px后面添加`/*px*/`,会根据dpr的不同，生成三套代码。---- 一般字体需用这个\n\n","source":"_posts/2019-01-01-Vue中使用px2rem把px转换为rem.md","raw":"---\ntitle: Vue中使用px2rem把px转换为rem\ndate: 2019-01-01 13:27:07\ntags:\n    -Vue\n---\n\n## Vue中使用px2rem把px转换为rem\n使用Vue做移动端页面时，适配是必须的，rem不失为一种好的选择，可在不同屏幕上完美显示相同的布局\npx2rem插件可以使`<style></style>`中的px单位根据设计稿转换为rem\n\n### 1.安装\n> npm install px2rem-loader -S\n\n### 2.配置`px2rem-loader`\n在`build/utils.js`的15行`export.assetsPath = function(_pth){...}`里面添加：\n\n```JavaScript\n    export.cssLoaders = funtion(options){\n        option = option || {}\n        const cssLoader = {\n            loader:'css-loader',\n            options:{\n                sourceMap:options.sourceMap\n            }\n        }\n        //\b下面为添加的代码\n        const px2RemLoader = {\n            loader:'px2rem-loader',\n            options:{\n                remUnit:75 //设计稿宽度的10%\n            }\n        }\n        const postcssLoader = {\n            loader:'postcss=loader',\n            options:{\n                sourceMap:options.sourceMap\n            }\n        }\n    }\n```\n### 3.修改`function generateLoader(loader,loaderOptions){...}`    \n将`const loader = ...`后面的三元运算符问好后面的数组每一个都加上`px2remLoader`\n```JavaScript\n    function generateLoaders(loader, loaderOptions){\n        const loaders = option.usePostCss ? [cssLoader, postcssLoader, px2remLoader] : [cssLoader, px2remLoader]\n\n        if(loader) {\n            ....\n        }\n    }\n```\n### 4.使用\n```html\n    <style lang=\"\" scoped>\n        .wrap{\n            width:750px; /** 上面的remUnit：75的时候为10rem **/\n            height:1334px\n        }\n    </style>\n```\n### 5.注意事项\n安装px2rem后，再使用px上有些不同，大家可以参考px2rem官方介绍，下面简单介绍一下。  \n1，直接写px，编译后会直接转化成rem ---- 除开下面两种情况，其他长度用这个  \n\n2，在px后面添加`/*no*/`，不会转化px，会原样输出。 --- 一般border需用这个    \n\n3，在px后面添加`/*px*/`,会根据dpr的不同，生成三套代码。---- 一般字体需用这个\n\n","slug":"2019-01-01-Vue中使用px2rem把px转换为rem","published":1,"updated":"2019-03-05T14:54:03.771Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjtviomw60007btzi01h9hd0g","content":"<h2 id=\"Vue中使用px2rem把px转换为rem\"><a href=\"#Vue中使用px2rem把px转换为rem\" class=\"headerlink\" title=\"Vue中使用px2rem把px转换为rem\"></a>Vue中使用px2rem把px转换为rem</h2><p>使用Vue做移动端页面时，适配是必须的，rem不失为一种好的选择，可在不同屏幕上完美显示相同的布局<br>px2rem插件可以使<code>&lt;style&gt;&lt;/style&gt;</code>中的px单位根据设计稿转换为rem</p>\n<h3 id=\"1-安装\"><a href=\"#1-安装\" class=\"headerlink\" title=\"1.安装\"></a>1.安装</h3><blockquote>\n<p>npm install px2rem-loader -S</p>\n</blockquote>\n<h3 id=\"2-配置px2rem-loader\"><a href=\"#2-配置px2rem-loader\" class=\"headerlink\" title=\"2.配置px2rem-loader\"></a>2.配置<code>px2rem-loader</code></h3><p>在<code>build/utils.js</code>的15行<code>export.assetsPath = function(_pth){...}</code>里面添加：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">export</span>.cssLoaders = funtion(options)&#123;</span><br><span class=\"line\">    option = option || &#123;&#125;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> cssLoader = &#123;</span><br><span class=\"line\">        loader:<span class=\"string\">'css-loader'</span>,</span><br><span class=\"line\">        options:&#123;</span><br><span class=\"line\">            sourceMap:options.sourceMap</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">//\b下面为添加的代码</span></span><br><span class=\"line\">    <span class=\"keyword\">const</span> px2RemLoader = &#123;</span><br><span class=\"line\">        loader:<span class=\"string\">'px2rem-loader'</span>,</span><br><span class=\"line\">        options:&#123;</span><br><span class=\"line\">            remUnit:<span class=\"number\">75</span> <span class=\"comment\">//设计稿宽度的10%</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> postcssLoader = &#123;</span><br><span class=\"line\">        loader:<span class=\"string\">'postcss=loader'</span>,</span><br><span class=\"line\">        options:&#123;</span><br><span class=\"line\">            sourceMap:options.sourceMap</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"3-修改function-generateLoader-loader-loaderOptions\"><a href=\"#3-修改function-generateLoader-loader-loaderOptions\" class=\"headerlink\" title=\"3.修改function generateLoader(loader,loaderOptions){...}\"></a>3.修改<code>function generateLoader(loader,loaderOptions){...}</code></h3><p>将<code>const loader = ...</code>后面的三元运算符问好后面的数组每一个都加上<code>px2remLoader</code><br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">generateLoaders</span>(<span class=\"params\">loader, loaderOptions</span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> loaders = option.usePostCss ? [cssLoader, postcssLoader, px2remLoader] : [cssLoader, px2remLoader]</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span>(loader) &#123;</span><br><span class=\"line\">        ....</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"4-使用\"><a href=\"#4-使用\" class=\"headerlink\" title=\"4.使用\"></a>4.使用</h3><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">style</span> <span class=\"attr\">lang</span>=<span class=\"string\">\"\"</span> <span class=\"attr\">scoped</span>&gt;</span><span class=\"undefined\"></span></span><br><span class=\"line\"><span class=\"undefined\">    .wrap&#123;</span></span><br><span class=\"line\"><span class=\"undefined\">        width:750px; /** 上面的remUnit：75的时候为10rem **/</span></span><br><span class=\"line\"><span class=\"undefined\">        height:1334px</span></span><br><span class=\"line\"><span class=\"undefined\">    &#125;</span></span><br><span class=\"line\"><span class=\"undefined\"></span><span class=\"tag\">&lt;/<span class=\"name\">style</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"5-注意事项\"><a href=\"#5-注意事项\" class=\"headerlink\" title=\"5.注意事项\"></a>5.注意事项</h3><p>安装px2rem后，再使用px上有些不同，大家可以参考px2rem官方介绍，下面简单介绍一下。<br>1，直接写px，编译后会直接转化成rem —- 除开下面两种情况，其他长度用这个  </p>\n<p>2，在px后面添加<code>/*no*/</code>，不会转化px，会原样输出。 — 一般border需用这个    </p>\n<p>3，在px后面添加<code>/*px*/</code>,会根据dpr的不同，生成三套代码。—- 一般字体需用这个</p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"Vue中使用px2rem把px转换为rem\"><a href=\"#Vue中使用px2rem把px转换为rem\" class=\"headerlink\" title=\"Vue中使用px2rem把px转换为rem\"></a>Vue中使用px2rem把px转换为rem</h2><p>使用Vue做移动端页面时，适配是必须的，rem不失为一种好的选择，可在不同屏幕上完美显示相同的布局<br>px2rem插件可以使<code>&lt;style&gt;&lt;/style&gt;</code>中的px单位根据设计稿转换为rem</p>\n<h3 id=\"1-安装\"><a href=\"#1-安装\" class=\"headerlink\" title=\"1.安装\"></a>1.安装</h3><blockquote>\n<p>npm install px2rem-loader -S</p>\n</blockquote>\n<h3 id=\"2-配置px2rem-loader\"><a href=\"#2-配置px2rem-loader\" class=\"headerlink\" title=\"2.配置px2rem-loader\"></a>2.配置<code>px2rem-loader</code></h3><p>在<code>build/utils.js</code>的15行<code>export.assetsPath = function(_pth){...}</code>里面添加：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">export</span>.cssLoaders = funtion(options)&#123;</span><br><span class=\"line\">    option = option || &#123;&#125;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> cssLoader = &#123;</span><br><span class=\"line\">        loader:<span class=\"string\">'css-loader'</span>,</span><br><span class=\"line\">        options:&#123;</span><br><span class=\"line\">            sourceMap:options.sourceMap</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">//\b下面为添加的代码</span></span><br><span class=\"line\">    <span class=\"keyword\">const</span> px2RemLoader = &#123;</span><br><span class=\"line\">        loader:<span class=\"string\">'px2rem-loader'</span>,</span><br><span class=\"line\">        options:&#123;</span><br><span class=\"line\">            remUnit:<span class=\"number\">75</span> <span class=\"comment\">//设计稿宽度的10%</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> postcssLoader = &#123;</span><br><span class=\"line\">        loader:<span class=\"string\">'postcss=loader'</span>,</span><br><span class=\"line\">        options:&#123;</span><br><span class=\"line\">            sourceMap:options.sourceMap</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"3-修改function-generateLoader-loader-loaderOptions\"><a href=\"#3-修改function-generateLoader-loader-loaderOptions\" class=\"headerlink\" title=\"3.修改function generateLoader(loader,loaderOptions){...}\"></a>3.修改<code>function generateLoader(loader,loaderOptions){...}</code></h3><p>将<code>const loader = ...</code>后面的三元运算符问好后面的数组每一个都加上<code>px2remLoader</code><br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">generateLoaders</span>(<span class=\"params\">loader, loaderOptions</span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> loaders = option.usePostCss ? [cssLoader, postcssLoader, px2remLoader] : [cssLoader, px2remLoader]</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span>(loader) &#123;</span><br><span class=\"line\">        ....</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"4-使用\"><a href=\"#4-使用\" class=\"headerlink\" title=\"4.使用\"></a>4.使用</h3><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">style</span> <span class=\"attr\">lang</span>=<span class=\"string\">\"\"</span> <span class=\"attr\">scoped</span>&gt;</span><span class=\"undefined\"></span></span><br><span class=\"line\"><span class=\"undefined\">    .wrap&#123;</span></span><br><span class=\"line\"><span class=\"undefined\">        width:750px; /** 上面的remUnit：75的时候为10rem **/</span></span><br><span class=\"line\"><span class=\"undefined\">        height:1334px</span></span><br><span class=\"line\"><span class=\"undefined\">    &#125;</span></span><br><span class=\"line\"><span class=\"undefined\"></span><span class=\"tag\">&lt;/<span class=\"name\">style</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"5-注意事项\"><a href=\"#5-注意事项\" class=\"headerlink\" title=\"5.注意事项\"></a>5.注意事项</h3><p>安装px2rem后，再使用px上有些不同，大家可以参考px2rem官方介绍，下面简单介绍一下。<br>1，直接写px，编译后会直接转化成rem —- 除开下面两种情况，其他长度用这个  </p>\n<p>2，在px后面添加<code>/*no*/</code>，不会转化px，会原样输出。 — 一般border需用这个    </p>\n<p>3，在px后面添加<code>/*px*/</code>,会根据dpr的不同，生成三套代码。—- 一般字体需用这个</p>\n"},{"title":"Vue中使用scss和scss语法使用","date":"2019-01-01T05:55:49.000Z","_content":"## Vue中使用SCSS\n### 1.scss介绍\n\nSass是成熟、稳定、强大的CSS预处理器，而SCSS是Sass3版本当中引入的新语法特性，完全兼容CSS3的同时继承了Sass强大的动态功能   \n### 2.特性\nCSS书写代码规模较大的Web应用时，容易造成选择器、层叠的复杂度过高，因此推荐通过SASS预处理器进行CSS的开发，SASS提供的变量、嵌套、混合、继承等特性，让CSS的书写更加有趣与程式化。\n### 3.安装\n>npm install node-sass -S   \n>npm install sass-loader -S  \n\n修改`build/webpack.base.conf.js`在`module.exports={...}`中的`module:{...}`添加     \n\n```JavaScript\n    module.exports = {\n        context:path.resolve(__dirname,'../')\n        entry:{\n            app:'./src/main.js'\n        },\n        ...\n        modules:{\n            rules:[\n                {\n                    test:/\\.vue$/,\n                    loader:'vue-loader',\n                    options:vueLoaderConfig\n                },\n                ...\n                //下面是添加的代码\n                {\n                    test:/\\.sass$/,\n                    loader:['style','css','sass']\n                }\n            ]\n        }\n    }\n```\n### 4.sass/scss语法介绍\n#### 变量\n变量用来存储需要在CSS中复用的信息，例如颜色和字体。SASS通过$符号去声明一个变量。   \n```css\n    $color:#333;\n    body{\n        color:$color;\n        background:$color;\n    }\n```\n上面的将会转化为:\n```css\n    body{\n        color:#333;\n        background:#333;\n    }\n```\n#### 嵌套\nSASS允许开发人员以嵌套的方式使用CSS，但是过度的使用嵌套会让产生的CSS难以维护，因此是一种不好的实践，下面的例子表达了一个典型的网站导航样式\n```css\n    $normalColor:#f7f7f7\n    nav {\n        width:100%;\n        ul {\n            list-style:none;\n            li {\n                width:100%\n                a {\n                    color:$normalColor\n                }\n            }\n        }\n    }\n```\n上面代码将转为：\n```css\n    nav {\n        width:100%;\n    }\n    nav ul {\n        list-style:none;\n    }\n    nav ul li {\n        width:100%;\n    }\n    nav ul li a {\n        color:#f7f7f7\n    }\n```\n#### 引入\nSASS能够将代码分割为多个片段，并以underscore风格的下划线作为其命名前缀（_partial.scss），SASS会通过这些下划线来辨别哪些文件是SASS片段，并且不让片段内容直接生成为CSS文件，从而只是在使用@import指令的位置被导入。CSS原生的@import会通过额外的HTTP请求获取引入的样式片段，而SASS的@import则会直接将这些引入的片段合并至当前CSS文件，并且不会产生新的HTTP请求。下面例子中的代码，将会在base.scss文件当中引入_reset.scss片断。\n```css\n    // _reset.scss\n    html, body, ul, ol {\n        margin:  0;\n        padding: 0;\n    }\n\n    // base.scss\n    @import 'reset';\n    body {\n        font: 100% Helvetica, sans-serif;\n        background-color: #efefef;\n    }\n```\nSASS中引入片断时，可以缺省使用文件扩展名，因此上面代码中直接通过@import 'reset'引入，编译后生成的代码如下：\n```css\n    html, body, ul, ol {\n        margin: 0;\n        padding: 0; \n    }\n\n    body {\n        font: 100% Helvetica, sans-serif;\n        background-color: #efefef; \n    }\n```\n#### 混合\n混合（Mixin）用来分组那些需要在页面中复用的CSS声明，开发人员可以通过向Mixin传递变量参数来让代码更加灵活，该特性在添加浏览器兼容性前缀的时候非常有用，SASS目前使用@mixin name指令来进行混合操作。\n```css\n    @mixin border-radius($radius) {\n                border-radius: $radius;\n            -ms-border-radius: $radius;\n            -moz-border-radius: $radius;\n        -webkit-border-radius: $radius;\n    }\n\n    .box {\n        @include border-radius(10px);\n    }\n\n```\n上面的代码建立了一个名为border-radius的Mixin，并传递了一个变量$radius作为参数，然后在后续代码中通过@include border-radius(10px)使用该Mixin，最终编译的结果如下：\n```css\n    .box {\n        border-radius: 10px;\n        -ms-border-radius: 10px;\n        -moz-border-radius: 10px;\n        -webkit-border-radius: 10px; \n    }\n```\n#### 继承\n继承是SASS中非常重要的一个特性，可以通过@extend指令在选择器之间复用CSS属性，并且不会产生冗余的代码，下面例子将会通过SASS提供的继承机制建立一系列样式：\n```css\n    // 这段代码不会被输出到最终生成的CSS文件，因为它没有被任何代码所继承。\n    %other-styles {\n        display: flex;\n        flex-wrap: wrap;\n    }\n\n    // 下面代码会正常输出到生成的CSS文件，因为它被其接下来的代码所继承。\n    %message-common {\n        border: 1px solid #ccc;\n        padding: 10px;\n        color: #333;\n    }\n\n    .message {\n        @extend %message-common;\n    }\n\n    .success {\n        @extend %message-common;\n        border-color: green;\n    }\n\n    .error {\n        @extend %message-common;\n        border-color: red;\n    }\n\n    .warning {\n        @extend %message-common;\n        border-color: yellow;\n    }\n\n```\n上面代码将.message中的CSS属性应用到了.success、.error、.warning上面，魔法将会发生在最终生成的CSS当中。这种方式能够避免在HTML元素上书写多个class选择器，最终生成的CSS样式是下面这样的：\n```css\n    .message, .success, .error, .warning {\n        border: 1px solid #ccc;\n        padding: 10px;\n        color: #333; \n    }\n\n    .success {\n        border-color: green; \n    }\n\n    .error {\n        border-color: red; \n    }\n\n    .warning {\n        border-color: yellow; \n    }\n\n```\n#### 操作符\nSASS提供了标准的算术运算符，例如+、-、*、/、%。在接下来的例子里，我们尝试在aside和article选择器当中对宽度进行简单的计算。\n```css\n    .container { width: 100%; }\n\n    article[role=\"main\"] {\n        float: left;\n        width: 600px / 960px * 100%;\n    }\n\n    aside[role=\"complementary\"] {\n        float: right;\n        width: 300px / 960px * 100%;\n    }\n\n```\n上面代码以960px为基准建立了简单的流式网格布局，SASS提供的算术运算符让开发人员可以更容易的将像素值转换为百分比，最终生成的CSS样式如下所示：\n```css\n    .container {\n        width: 100%; \n    }\n\n    article[role=\"main\"] {\n        float: left;\n        width: 62.5%; \n    }\n\n    aside[role=\"complementary\"] {\n        float: right;\n        width: 31.25%; \n    }\n```\n#### CSS扩展\nScss使用\"&\"关键字在CSS规则中引用父级选择器，例如在嵌套使用伪类选择器的场景下：\n```css\n/*===== SCSS =====*/\n    a {\n        font-weight: bold;\n        text-decoration: none;\n        &:hover { text-decoration: underline; }\n        body.firefox & { font-weight: normal; }\n    }\n\n    /*===== CSS =====*/\n    a {\n        font-weight: bold;\n        text-decoration: none; \n    }\n    a:hover {\n        text-decoration: underline;\n    }\n    body.firefox a {\n        font-weight: normal; \n    }\n```\n无论CSS规则嵌套的深度怎样，关键字\"&\"都会使用父级选择器级联替换全部其出现的位置：\n```css\n    /*===== SCSS =====*/\n    #main {\n        color: black;\n        a {\n            font-weight: bold;\n            &:hover { color: red; }\n        }\n    }\n\n/*===== CSS =====*/\n    #main {\n        color: black; \n    }\n    #main a {\n        font-weight: bold; \n    }\n    #main a:hover {\n      color: red; \n    }\n\n```\n\"&\"必须出现在复合选择器开头的位置，后面再连接自定义的后缀，例如：\n```css\n    /*===== SCSS =====*/\n    #main {\n        color: black;\n        &-sidebar { \n            border: 1px solid; \n        }\n    }\n\n    /*===== CSS =====*/\n    #main {\n        color: black; \n    }\n    #main-sidebar {\n        border: 1px solid; \n    }\n\n```\n如果在父级选择器不存在的场景使用&，Scss预处理器会报出错误信息。\n#### 嵌套属性\nCSS许多属性都位于相同的命名空间（例如font-family、font-size、font-weight都位于font命名空间下），Scss当中只需要编写命名空间一次，后续嵌套的子属性都将会位于该命名空间之下，请看下面的代码：\n```css\n    /*===== SCSS =====*/\n    .demo {\n    // 命令空间后带有冒号:\n        font: {\n            family: fantasy;\n            size: 30em;\n            weight: bold;\n        }\n    }\n\n    /*===== CSS =====*/\n    .demo {\n        font-family: fantasy;\n        font-size: 30em;\n        font-weight: bold; \n    }\n\n```\n命令空间上可以直接书写CSS简写属性，但是日常开发中建议直接书写CSS简写属性，尽量保持CSS语法的一致性。\n```css\n    .demo {\n        font: 20px/24px fantasy {\n            weight: bold;\n        }\n    }\n\n    .demo {\n        font: 20px/24px fantasy;\n            font-weight: bold;\n        }sass\n\n```\n参考文章 [简书](https://www.jianshu.com/p/a99764ff3c41)\n\n","source":"_posts/2019-01-01-Vue中使用scss和sass语法.md","raw":"---\ntitle: Vue中使用scss和scss语法使用\ndate: 2019-01-01 13:55:49\ntags:\n    -Vue\n---\n## Vue中使用SCSS\n### 1.scss介绍\n\nSass是成熟、稳定、强大的CSS预处理器，而SCSS是Sass3版本当中引入的新语法特性，完全兼容CSS3的同时继承了Sass强大的动态功能   \n### 2.特性\nCSS书写代码规模较大的Web应用时，容易造成选择器、层叠的复杂度过高，因此推荐通过SASS预处理器进行CSS的开发，SASS提供的变量、嵌套、混合、继承等特性，让CSS的书写更加有趣与程式化。\n### 3.安装\n>npm install node-sass -S   \n>npm install sass-loader -S  \n\n修改`build/webpack.base.conf.js`在`module.exports={...}`中的`module:{...}`添加     \n\n```JavaScript\n    module.exports = {\n        context:path.resolve(__dirname,'../')\n        entry:{\n            app:'./src/main.js'\n        },\n        ...\n        modules:{\n            rules:[\n                {\n                    test:/\\.vue$/,\n                    loader:'vue-loader',\n                    options:vueLoaderConfig\n                },\n                ...\n                //下面是添加的代码\n                {\n                    test:/\\.sass$/,\n                    loader:['style','css','sass']\n                }\n            ]\n        }\n    }\n```\n### 4.sass/scss语法介绍\n#### 变量\n变量用来存储需要在CSS中复用的信息，例如颜色和字体。SASS通过$符号去声明一个变量。   \n```css\n    $color:#333;\n    body{\n        color:$color;\n        background:$color;\n    }\n```\n上面的将会转化为:\n```css\n    body{\n        color:#333;\n        background:#333;\n    }\n```\n#### 嵌套\nSASS允许开发人员以嵌套的方式使用CSS，但是过度的使用嵌套会让产生的CSS难以维护，因此是一种不好的实践，下面的例子表达了一个典型的网站导航样式\n```css\n    $normalColor:#f7f7f7\n    nav {\n        width:100%;\n        ul {\n            list-style:none;\n            li {\n                width:100%\n                a {\n                    color:$normalColor\n                }\n            }\n        }\n    }\n```\n上面代码将转为：\n```css\n    nav {\n        width:100%;\n    }\n    nav ul {\n        list-style:none;\n    }\n    nav ul li {\n        width:100%;\n    }\n    nav ul li a {\n        color:#f7f7f7\n    }\n```\n#### 引入\nSASS能够将代码分割为多个片段，并以underscore风格的下划线作为其命名前缀（_partial.scss），SASS会通过这些下划线来辨别哪些文件是SASS片段，并且不让片段内容直接生成为CSS文件，从而只是在使用@import指令的位置被导入。CSS原生的@import会通过额外的HTTP请求获取引入的样式片段，而SASS的@import则会直接将这些引入的片段合并至当前CSS文件，并且不会产生新的HTTP请求。下面例子中的代码，将会在base.scss文件当中引入_reset.scss片断。\n```css\n    // _reset.scss\n    html, body, ul, ol {\n        margin:  0;\n        padding: 0;\n    }\n\n    // base.scss\n    @import 'reset';\n    body {\n        font: 100% Helvetica, sans-serif;\n        background-color: #efefef;\n    }\n```\nSASS中引入片断时，可以缺省使用文件扩展名，因此上面代码中直接通过@import 'reset'引入，编译后生成的代码如下：\n```css\n    html, body, ul, ol {\n        margin: 0;\n        padding: 0; \n    }\n\n    body {\n        font: 100% Helvetica, sans-serif;\n        background-color: #efefef; \n    }\n```\n#### 混合\n混合（Mixin）用来分组那些需要在页面中复用的CSS声明，开发人员可以通过向Mixin传递变量参数来让代码更加灵活，该特性在添加浏览器兼容性前缀的时候非常有用，SASS目前使用@mixin name指令来进行混合操作。\n```css\n    @mixin border-radius($radius) {\n                border-radius: $radius;\n            -ms-border-radius: $radius;\n            -moz-border-radius: $radius;\n        -webkit-border-radius: $radius;\n    }\n\n    .box {\n        @include border-radius(10px);\n    }\n\n```\n上面的代码建立了一个名为border-radius的Mixin，并传递了一个变量$radius作为参数，然后在后续代码中通过@include border-radius(10px)使用该Mixin，最终编译的结果如下：\n```css\n    .box {\n        border-radius: 10px;\n        -ms-border-radius: 10px;\n        -moz-border-radius: 10px;\n        -webkit-border-radius: 10px; \n    }\n```\n#### 继承\n继承是SASS中非常重要的一个特性，可以通过@extend指令在选择器之间复用CSS属性，并且不会产生冗余的代码，下面例子将会通过SASS提供的继承机制建立一系列样式：\n```css\n    // 这段代码不会被输出到最终生成的CSS文件，因为它没有被任何代码所继承。\n    %other-styles {\n        display: flex;\n        flex-wrap: wrap;\n    }\n\n    // 下面代码会正常输出到生成的CSS文件，因为它被其接下来的代码所继承。\n    %message-common {\n        border: 1px solid #ccc;\n        padding: 10px;\n        color: #333;\n    }\n\n    .message {\n        @extend %message-common;\n    }\n\n    .success {\n        @extend %message-common;\n        border-color: green;\n    }\n\n    .error {\n        @extend %message-common;\n        border-color: red;\n    }\n\n    .warning {\n        @extend %message-common;\n        border-color: yellow;\n    }\n\n```\n上面代码将.message中的CSS属性应用到了.success、.error、.warning上面，魔法将会发生在最终生成的CSS当中。这种方式能够避免在HTML元素上书写多个class选择器，最终生成的CSS样式是下面这样的：\n```css\n    .message, .success, .error, .warning {\n        border: 1px solid #ccc;\n        padding: 10px;\n        color: #333; \n    }\n\n    .success {\n        border-color: green; \n    }\n\n    .error {\n        border-color: red; \n    }\n\n    .warning {\n        border-color: yellow; \n    }\n\n```\n#### 操作符\nSASS提供了标准的算术运算符，例如+、-、*、/、%。在接下来的例子里，我们尝试在aside和article选择器当中对宽度进行简单的计算。\n```css\n    .container { width: 100%; }\n\n    article[role=\"main\"] {\n        float: left;\n        width: 600px / 960px * 100%;\n    }\n\n    aside[role=\"complementary\"] {\n        float: right;\n        width: 300px / 960px * 100%;\n    }\n\n```\n上面代码以960px为基准建立了简单的流式网格布局，SASS提供的算术运算符让开发人员可以更容易的将像素值转换为百分比，最终生成的CSS样式如下所示：\n```css\n    .container {\n        width: 100%; \n    }\n\n    article[role=\"main\"] {\n        float: left;\n        width: 62.5%; \n    }\n\n    aside[role=\"complementary\"] {\n        float: right;\n        width: 31.25%; \n    }\n```\n#### CSS扩展\nScss使用\"&\"关键字在CSS规则中引用父级选择器，例如在嵌套使用伪类选择器的场景下：\n```css\n/*===== SCSS =====*/\n    a {\n        font-weight: bold;\n        text-decoration: none;\n        &:hover { text-decoration: underline; }\n        body.firefox & { font-weight: normal; }\n    }\n\n    /*===== CSS =====*/\n    a {\n        font-weight: bold;\n        text-decoration: none; \n    }\n    a:hover {\n        text-decoration: underline;\n    }\n    body.firefox a {\n        font-weight: normal; \n    }\n```\n无论CSS规则嵌套的深度怎样，关键字\"&\"都会使用父级选择器级联替换全部其出现的位置：\n```css\n    /*===== SCSS =====*/\n    #main {\n        color: black;\n        a {\n            font-weight: bold;\n            &:hover { color: red; }\n        }\n    }\n\n/*===== CSS =====*/\n    #main {\n        color: black; \n    }\n    #main a {\n        font-weight: bold; \n    }\n    #main a:hover {\n      color: red; \n    }\n\n```\n\"&\"必须出现在复合选择器开头的位置，后面再连接自定义的后缀，例如：\n```css\n    /*===== SCSS =====*/\n    #main {\n        color: black;\n        &-sidebar { \n            border: 1px solid; \n        }\n    }\n\n    /*===== CSS =====*/\n    #main {\n        color: black; \n    }\n    #main-sidebar {\n        border: 1px solid; \n    }\n\n```\n如果在父级选择器不存在的场景使用&，Scss预处理器会报出错误信息。\n#### 嵌套属性\nCSS许多属性都位于相同的命名空间（例如font-family、font-size、font-weight都位于font命名空间下），Scss当中只需要编写命名空间一次，后续嵌套的子属性都将会位于该命名空间之下，请看下面的代码：\n```css\n    /*===== SCSS =====*/\n    .demo {\n    // 命令空间后带有冒号:\n        font: {\n            family: fantasy;\n            size: 30em;\n            weight: bold;\n        }\n    }\n\n    /*===== CSS =====*/\n    .demo {\n        font-family: fantasy;\n        font-size: 30em;\n        font-weight: bold; \n    }\n\n```\n命令空间上可以直接书写CSS简写属性，但是日常开发中建议直接书写CSS简写属性，尽量保持CSS语法的一致性。\n```css\n    .demo {\n        font: 20px/24px fantasy {\n            weight: bold;\n        }\n    }\n\n    .demo {\n        font: 20px/24px fantasy;\n            font-weight: bold;\n        }sass\n\n```\n参考文章 [简书](https://www.jianshu.com/p/a99764ff3c41)\n\n","slug":"2019-01-01-Vue中使用scss和sass语法","published":1,"updated":"2019-03-05T14:54:18.023Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjtviomw8000abtzi9s1tspnz","content":"<h2 id=\"Vue中使用SCSS\"><a href=\"#Vue中使用SCSS\" class=\"headerlink\" title=\"Vue中使用SCSS\"></a>Vue中使用SCSS</h2><h3 id=\"1-scss介绍\"><a href=\"#1-scss介绍\" class=\"headerlink\" title=\"1.scss介绍\"></a>1.scss介绍</h3><p>Sass是成熟、稳定、强大的CSS预处理器，而SCSS是Sass3版本当中引入的新语法特性，完全兼容CSS3的同时继承了Sass强大的动态功能   </p>\n<h3 id=\"2-特性\"><a href=\"#2-特性\" class=\"headerlink\" title=\"2.特性\"></a>2.特性</h3><p>CSS书写代码规模较大的Web应用时，容易造成选择器、层叠的复杂度过高，因此推荐通过SASS预处理器进行CSS的开发，SASS提供的变量、嵌套、混合、继承等特性，让CSS的书写更加有趣与程式化。</p>\n<h3 id=\"3-安装\"><a href=\"#3-安装\" class=\"headerlink\" title=\"3.安装\"></a>3.安装</h3><blockquote>\n<p>npm install node-sass -S<br>npm install sass-loader -S  </p>\n</blockquote>\n<p>修改<code>build/webpack.base.conf.js</code>在<code>module.exports={...}</code>中的<code>module:{...}</code>添加     </p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">module</span>.exports = &#123;</span><br><span class=\"line\">    context:path.resolve(__dirname,<span class=\"string\">'../'</span>)</span><br><span class=\"line\">    entry:&#123;</span><br><span class=\"line\">        app:<span class=\"string\">'./src/main.js'</span></span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    ...</span><br><span class=\"line\">    modules:&#123;</span><br><span class=\"line\">        rules:[</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                test:<span class=\"regexp\">/\\.vue$/</span>,</span><br><span class=\"line\">                loader:<span class=\"string\">'vue-loader'</span>,</span><br><span class=\"line\">                options:vueLoaderConfig</span><br><span class=\"line\">            &#125;,</span><br><span class=\"line\">            ...</span><br><span class=\"line\">            <span class=\"comment\">//下面是添加的代码</span></span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                test:<span class=\"regexp\">/\\.sass$/</span>,</span><br><span class=\"line\">                loader:[<span class=\"string\">'style'</span>,<span class=\"string\">'css'</span>,<span class=\"string\">'sass'</span>]</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        ]</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"4-sass-scss语法介绍\"><a href=\"#4-sass-scss语法介绍\" class=\"headerlink\" title=\"4.sass/scss语法介绍\"></a>4.sass/scss语法介绍</h3><h4 id=\"变量\"><a href=\"#变量\" class=\"headerlink\" title=\"变量\"></a>变量</h4><p>变量用来存储需要在CSS中复用的信息，例如颜色和字体。SASS通过$符号去声明一个变量。<br><figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$color:#333;</span><br><span class=\"line\"><span class=\"selector-tag\">body</span>&#123;</span><br><span class=\"line\">    <span class=\"attribute\">color</span>:$color;</span><br><span class=\"line\">    <span class=\"attribute\">background</span>:$color;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>上面的将会转化为:<br><figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-tag\">body</span>&#123;</span><br><span class=\"line\">    <span class=\"attribute\">color</span>:<span class=\"number\">#333</span>;</span><br><span class=\"line\">    <span class=\"attribute\">background</span>:<span class=\"number\">#333</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"嵌套\"><a href=\"#嵌套\" class=\"headerlink\" title=\"嵌套\"></a>嵌套</h4><p>SASS允许开发人员以嵌套的方式使用CSS，但是过度的使用嵌套会让产生的CSS难以维护，因此是一种不好的实践，下面的例子表达了一个典型的网站导航样式<br><figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$normalColor:#f7f7f7</span><br><span class=\"line\"><span class=\"selector-tag\">nav</span> &#123;</span><br><span class=\"line\">    <span class=\"attribute\">width</span>:<span class=\"number\">100%</span>;</span><br><span class=\"line\">    ul &#123;</span><br><span class=\"line\">        <span class=\"selector-tag\">list-style</span><span class=\"selector-pseudo\">:none</span>;</span><br><span class=\"line\">        <span class=\"selector-tag\">li</span> &#123;</span><br><span class=\"line\">            <span class=\"attribute\">width</span>:<span class=\"number\">100%</span></span><br><span class=\"line\">            a &#123;</span><br><span class=\"line\">                color:$normalColor</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>上面代码将转为：<br><figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-tag\">nav</span> &#123;</span><br><span class=\"line\">    <span class=\"attribute\">width</span>:<span class=\"number\">100%</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"selector-tag\">nav</span> <span class=\"selector-tag\">ul</span> &#123;</span><br><span class=\"line\">    <span class=\"attribute\">list-style</span>:none;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"selector-tag\">nav</span> <span class=\"selector-tag\">ul</span> <span class=\"selector-tag\">li</span> &#123;</span><br><span class=\"line\">    <span class=\"attribute\">width</span>:<span class=\"number\">100%</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"selector-tag\">nav</span> <span class=\"selector-tag\">ul</span> <span class=\"selector-tag\">li</span> <span class=\"selector-tag\">a</span> &#123;</span><br><span class=\"line\">    <span class=\"attribute\">color</span>:<span class=\"number\">#f7f7f7</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"引入\"><a href=\"#引入\" class=\"headerlink\" title=\"引入\"></a>引入</h4><p>SASS能够将代码分割为多个片段，并以underscore风格的下划线作为其命名前缀（_partial.scss），SASS会通过这些下划线来辨别哪些文件是SASS片段，并且不让片段内容直接生成为CSS文件，从而只是在使用@import指令的位置被导入。CSS原生的@import会通过额外的HTTP请求获取引入的样式片段，而SASS的@import则会直接将这些引入的片段合并至当前CSS文件，并且不会产生新的HTTP请求。下面例子中的代码，将会在base.scss文件当中引入_reset.scss片断。<br><figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// _reset.scss</span><br><span class=\"line\"><span class=\"selector-tag\">html</span>, <span class=\"selector-tag\">body</span>, <span class=\"selector-tag\">ul</span>, <span class=\"selector-tag\">ol</span> &#123;</span><br><span class=\"line\">    <span class=\"attribute\">margin</span>:  <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"attribute\">padding</span>: <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// base.scss</span><br><span class=\"line\">@<span class=\"keyword\">import</span> <span class=\"string\">'reset'</span>;</span><br><span class=\"line\"><span class=\"selector-tag\">body</span> &#123;</span><br><span class=\"line\">    <span class=\"attribute\">font</span>: <span class=\"number\">100%</span> Helvetica, sans-serif;</span><br><span class=\"line\">    <span class=\"attribute\">background-color</span>: <span class=\"number\">#efefef</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>SASS中引入片断时，可以缺省使用文件扩展名，因此上面代码中直接通过@import ‘reset’引入，编译后生成的代码如下：<br><figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-tag\">html</span>, <span class=\"selector-tag\">body</span>, <span class=\"selector-tag\">ul</span>, <span class=\"selector-tag\">ol</span> &#123;</span><br><span class=\"line\">    <span class=\"attribute\">margin</span>: <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"attribute\">padding</span>: <span class=\"number\">0</span>; </span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"selector-tag\">body</span> &#123;</span><br><span class=\"line\">    <span class=\"attribute\">font</span>: <span class=\"number\">100%</span> Helvetica, sans-serif;</span><br><span class=\"line\">    <span class=\"attribute\">background-color</span>: <span class=\"number\">#efefef</span>; </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"混合\"><a href=\"#混合\" class=\"headerlink\" title=\"混合\"></a>混合</h4><p>混合（Mixin）用来分组那些需要在页面中复用的CSS声明，开发人员可以通过向Mixin传递变量参数来让代码更加灵活，该特性在添加浏览器兼容性前缀的时候非常有用，SASS目前使用@mixin name指令来进行混合操作。<br><figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@<span class=\"keyword\">mixin</span> border-radius($radius) &#123;</span><br><span class=\"line\">            border-radius: $radius;</span><br><span class=\"line\">        -ms-border-radius: $radius;</span><br><span class=\"line\">        -moz-border-radius: $radius;</span><br><span class=\"line\">    -webkit-border-radius: $radius;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"selector-class\">.box</span> &#123;</span><br><span class=\"line\">    @include border-radius(10px);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>上面的代码建立了一个名为border-radius的Mixin，并传递了一个变量$radius作为参数，然后在后续代码中通过@include border-radius(10px)使用该Mixin，最终编译的结果如下：<br><figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-class\">.box</span> &#123;</span><br><span class=\"line\">    <span class=\"attribute\">border-radius</span>: <span class=\"number\">10px</span>;</span><br><span class=\"line\">    <span class=\"attribute\">-ms-border-radius</span>: <span class=\"number\">10px</span>;</span><br><span class=\"line\">    <span class=\"attribute\">-moz-border-radius</span>: <span class=\"number\">10px</span>;</span><br><span class=\"line\">    <span class=\"attribute\">-webkit-border-radius</span>: <span class=\"number\">10px</span>; </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"继承\"><a href=\"#继承\" class=\"headerlink\" title=\"继承\"></a>继承</h4><p>继承是SASS中非常重要的一个特性，可以通过@extend指令在选择器之间复用CSS属性，并且不会产生冗余的代码，下面例子将会通过SASS提供的继承机制建立一系列样式：<br><figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 这段代码不会被输出到最终生成的CSS文件，因为它没有被任何代码所继承。</span><br><span class=\"line\">%<span class=\"selector-tag\">other-styles</span> &#123;</span><br><span class=\"line\">    <span class=\"attribute\">display</span>: flex;</span><br><span class=\"line\">    <span class=\"attribute\">flex-wrap</span>: wrap;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// 下面代码会正常输出到生成的CSS文件，因为它被其接下来的代码所继承。</span><br><span class=\"line\">%<span class=\"selector-tag\">message-common</span> &#123;</span><br><span class=\"line\">    <span class=\"attribute\">border</span>: <span class=\"number\">1px</span> solid <span class=\"number\">#ccc</span>;</span><br><span class=\"line\">    <span class=\"attribute\">padding</span>: <span class=\"number\">10px</span>;</span><br><span class=\"line\">    <span class=\"attribute\">color</span>: <span class=\"number\">#333</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"selector-class\">.message</span> &#123;</span><br><span class=\"line\">    @extend %message-common;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"selector-class\">.success</span> &#123;</span><br><span class=\"line\">    @extend %message-common;</span><br><span class=\"line\">    <span class=\"selector-tag\">border-color</span>: <span class=\"selector-tag\">green</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"selector-class\">.error</span> &#123;</span><br><span class=\"line\">    @extend %message-common;</span><br><span class=\"line\">    <span class=\"selector-tag\">border-color</span>: <span class=\"selector-tag\">red</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"selector-class\">.warning</span> &#123;</span><br><span class=\"line\">    @extend %message-common;</span><br><span class=\"line\">    <span class=\"selector-tag\">border-color</span>: <span class=\"selector-tag\">yellow</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>上面代码将.message中的CSS属性应用到了.success、.error、.warning上面，魔法将会发生在最终生成的CSS当中。这种方式能够避免在HTML元素上书写多个class选择器，最终生成的CSS样式是下面这样的：<br><figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-class\">.message</span>, <span class=\"selector-class\">.success</span>, <span class=\"selector-class\">.error</span>, <span class=\"selector-class\">.warning</span> &#123;</span><br><span class=\"line\">    <span class=\"attribute\">border</span>: <span class=\"number\">1px</span> solid <span class=\"number\">#ccc</span>;</span><br><span class=\"line\">    <span class=\"attribute\">padding</span>: <span class=\"number\">10px</span>;</span><br><span class=\"line\">    <span class=\"attribute\">color</span>: <span class=\"number\">#333</span>; </span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"selector-class\">.success</span> &#123;</span><br><span class=\"line\">    <span class=\"attribute\">border-color</span>: green; </span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"selector-class\">.error</span> &#123;</span><br><span class=\"line\">    <span class=\"attribute\">border-color</span>: red; </span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"selector-class\">.warning</span> &#123;</span><br><span class=\"line\">    <span class=\"attribute\">border-color</span>: yellow; </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"操作符\"><a href=\"#操作符\" class=\"headerlink\" title=\"操作符\"></a>操作符</h4><p>SASS提供了标准的算术运算符，例如+、-、*、/、%。在接下来的例子里，我们尝试在aside和article选择器当中对宽度进行简单的计算。<br><figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-class\">.container</span> &#123; <span class=\"attribute\">width</span>: <span class=\"number\">100%</span>; &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"selector-tag\">article</span><span class=\"selector-attr\">[role=\"main\"]</span> &#123;</span><br><span class=\"line\">    <span class=\"attribute\">float</span>: left;</span><br><span class=\"line\">    <span class=\"attribute\">width</span>: <span class=\"number\">600px</span> / <span class=\"number\">960px</span> * <span class=\"number\">100%</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"selector-tag\">aside</span><span class=\"selector-attr\">[role=\"complementary\"]</span> &#123;</span><br><span class=\"line\">    <span class=\"attribute\">float</span>: right;</span><br><span class=\"line\">    <span class=\"attribute\">width</span>: <span class=\"number\">300px</span> / <span class=\"number\">960px</span> * <span class=\"number\">100%</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>上面代码以960px为基准建立了简单的流式网格布局，SASS提供的算术运算符让开发人员可以更容易的将像素值转换为百分比，最终生成的CSS样式如下所示：<br><figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-class\">.container</span> &#123;</span><br><span class=\"line\">    <span class=\"attribute\">width</span>: <span class=\"number\">100%</span>; </span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"selector-tag\">article</span><span class=\"selector-attr\">[role=\"main\"]</span> &#123;</span><br><span class=\"line\">    <span class=\"attribute\">float</span>: left;</span><br><span class=\"line\">    <span class=\"attribute\">width</span>: <span class=\"number\">62.5%</span>; </span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"selector-tag\">aside</span><span class=\"selector-attr\">[role=\"complementary\"]</span> &#123;</span><br><span class=\"line\">    <span class=\"attribute\">float</span>: right;</span><br><span class=\"line\">    <span class=\"attribute\">width</span>: <span class=\"number\">31.25%</span>; </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"CSS扩展\"><a href=\"#CSS扩展\" class=\"headerlink\" title=\"CSS扩展\"></a>CSS扩展</h4><p>Scss使用”&amp;”关键字在CSS规则中引用父级选择器，例如在嵌套使用伪类选择器的场景下：<br><figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*===== SCSS =====*/</span></span><br><span class=\"line\">    <span class=\"selector-tag\">a</span> &#123;</span><br><span class=\"line\">        <span class=\"attribute\">font-weight</span>: bold;</span><br><span class=\"line\">        <span class=\"attribute\">text-decoration</span>: none;</span><br><span class=\"line\">        &amp;:hover &#123; text-decoration: underline; &#125;</span><br><span class=\"line\">        <span class=\"selector-tag\">body</span><span class=\"selector-class\">.firefox</span> &amp; &#123; <span class=\"attribute\">font-weight</span>: normal; &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/*===== CSS =====*/</span></span><br><span class=\"line\">    <span class=\"selector-tag\">a</span> &#123;</span><br><span class=\"line\">        <span class=\"attribute\">font-weight</span>: bold;</span><br><span class=\"line\">        <span class=\"attribute\">text-decoration</span>: none; </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"selector-tag\">a</span><span class=\"selector-pseudo\">:hover</span> &#123;</span><br><span class=\"line\">        <span class=\"attribute\">text-decoration</span>: underline;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"selector-tag\">body</span><span class=\"selector-class\">.firefox</span> <span class=\"selector-tag\">a</span> &#123;</span><br><span class=\"line\">        <span class=\"attribute\">font-weight</span>: normal; </span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure></p>\n<p>无论CSS规则嵌套的深度怎样，关键字”&amp;”都会使用父级选择器级联替换全部其出现的位置：<br><figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">    <span class=\"comment\">/*===== SCSS =====*/</span></span><br><span class=\"line\">    <span class=\"selector-id\">#main</span> &#123;</span><br><span class=\"line\">        <span class=\"attribute\">color</span>: black;</span><br><span class=\"line\">        a &#123;</span><br><span class=\"line\">            <span class=\"selector-tag\">font-weight</span>: <span class=\"selector-tag\">bold</span>;</span><br><span class=\"line\">            &amp;<span class=\"selector-pseudo\">:hover</span> &#123; <span class=\"attribute\">color</span>: red; &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/*===== CSS =====*/</span></span><br><span class=\"line\">    <span class=\"selector-id\">#main</span> &#123;</span><br><span class=\"line\">        <span class=\"attribute\">color</span>: black; </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"selector-id\">#main</span> <span class=\"selector-tag\">a</span> &#123;</span><br><span class=\"line\">        <span class=\"attribute\">font-weight</span>: bold; </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"selector-id\">#main</span> <span class=\"selector-tag\">a</span><span class=\"selector-pseudo\">:hover</span> &#123;</span><br><span class=\"line\">      <span class=\"attribute\">color</span>: red; </span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure></p>\n<p>“&amp;”必须出现在复合选择器开头的位置，后面再连接自定义的后缀，例如：<br><figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*===== SCSS =====*/</span></span><br><span class=\"line\"><span class=\"selector-id\">#main</span> &#123;</span><br><span class=\"line\">    <span class=\"attribute\">color</span>: black;</span><br><span class=\"line\">    &amp;-sidebar &#123; </span><br><span class=\"line\">        <span class=\"selector-tag\">border</span>: 1<span class=\"selector-tag\">px</span> <span class=\"selector-tag\">solid</span>; </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/*===== CSS =====*/</span></span><br><span class=\"line\"><span class=\"selector-id\">#main</span> &#123;</span><br><span class=\"line\">    <span class=\"attribute\">color</span>: black; </span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"selector-id\">#main-sidebar</span> &#123;</span><br><span class=\"line\">    <span class=\"attribute\">border</span>: <span class=\"number\">1px</span> solid; </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>如果在父级选择器不存在的场景使用&amp;，Scss预处理器会报出错误信息。</p>\n<h4 id=\"嵌套属性\"><a href=\"#嵌套属性\" class=\"headerlink\" title=\"嵌套属性\"></a>嵌套属性</h4><p>CSS许多属性都位于相同的命名空间（例如font-family、font-size、font-weight都位于font命名空间下），Scss当中只需要编写命名空间一次，后续嵌套的子属性都将会位于该命名空间之下，请看下面的代码：<br><figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*===== SCSS =====*/</span></span><br><span class=\"line\"><span class=\"selector-class\">.demo</span> &#123;</span><br><span class=\"line\">// 命令空间后带有冒号:</span><br><span class=\"line\">    <span class=\"selector-tag\">font</span>: &#123;</span><br><span class=\"line\">        <span class=\"attribute\">family</span>: fantasy;</span><br><span class=\"line\">        <span class=\"attribute\">size</span>: <span class=\"number\">30em</span>;</span><br><span class=\"line\">        <span class=\"attribute\">weight</span>: bold;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/*===== CSS =====*/</span></span><br><span class=\"line\"><span class=\"selector-class\">.demo</span> &#123;</span><br><span class=\"line\">    <span class=\"attribute\">font-family</span>: fantasy;</span><br><span class=\"line\">    <span class=\"attribute\">font-size</span>: <span class=\"number\">30em</span>;</span><br><span class=\"line\">    <span class=\"attribute\">font-weight</span>: bold; </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>命令空间上可以直接书写CSS简写属性，但是日常开发中建议直接书写CSS简写属性，尽量保持CSS语法的一致性。<br><figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-class\">.demo</span> &#123;</span><br><span class=\"line\">    <span class=\"attribute\">font</span>: <span class=\"number\">20px</span>/<span class=\"number\">24px</span> fantasy &#123;</span><br><span class=\"line\">        weight: bold;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"selector-class\">.demo</span> &#123;</span><br><span class=\"line\">    <span class=\"attribute\">font</span>: <span class=\"number\">20px</span>/<span class=\"number\">24px</span> fantasy;</span><br><span class=\"line\">        <span class=\"attribute\">font-weight</span>: bold;</span><br><span class=\"line\">    &#125;<span class=\"selector-tag\">sass</span></span><br></pre></td></tr></table></figure></p>\n<p>参考文章 <a href=\"https://www.jianshu.com/p/a99764ff3c41\" target=\"_blank\" rel=\"noopener\">简书</a></p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"Vue中使用SCSS\"><a href=\"#Vue中使用SCSS\" class=\"headerlink\" title=\"Vue中使用SCSS\"></a>Vue中使用SCSS</h2><h3 id=\"1-scss介绍\"><a href=\"#1-scss介绍\" class=\"headerlink\" title=\"1.scss介绍\"></a>1.scss介绍</h3><p>Sass是成熟、稳定、强大的CSS预处理器，而SCSS是Sass3版本当中引入的新语法特性，完全兼容CSS3的同时继承了Sass强大的动态功能   </p>\n<h3 id=\"2-特性\"><a href=\"#2-特性\" class=\"headerlink\" title=\"2.特性\"></a>2.特性</h3><p>CSS书写代码规模较大的Web应用时，容易造成选择器、层叠的复杂度过高，因此推荐通过SASS预处理器进行CSS的开发，SASS提供的变量、嵌套、混合、继承等特性，让CSS的书写更加有趣与程式化。</p>\n<h3 id=\"3-安装\"><a href=\"#3-安装\" class=\"headerlink\" title=\"3.安装\"></a>3.安装</h3><blockquote>\n<p>npm install node-sass -S<br>npm install sass-loader -S  </p>\n</blockquote>\n<p>修改<code>build/webpack.base.conf.js</code>在<code>module.exports={...}</code>中的<code>module:{...}</code>添加     </p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">module</span>.exports = &#123;</span><br><span class=\"line\">    context:path.resolve(__dirname,<span class=\"string\">'../'</span>)</span><br><span class=\"line\">    entry:&#123;</span><br><span class=\"line\">        app:<span class=\"string\">'./src/main.js'</span></span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    ...</span><br><span class=\"line\">    modules:&#123;</span><br><span class=\"line\">        rules:[</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                test:<span class=\"regexp\">/\\.vue$/</span>,</span><br><span class=\"line\">                loader:<span class=\"string\">'vue-loader'</span>,</span><br><span class=\"line\">                options:vueLoaderConfig</span><br><span class=\"line\">            &#125;,</span><br><span class=\"line\">            ...</span><br><span class=\"line\">            <span class=\"comment\">//下面是添加的代码</span></span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                test:<span class=\"regexp\">/\\.sass$/</span>,</span><br><span class=\"line\">                loader:[<span class=\"string\">'style'</span>,<span class=\"string\">'css'</span>,<span class=\"string\">'sass'</span>]</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        ]</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"4-sass-scss语法介绍\"><a href=\"#4-sass-scss语法介绍\" class=\"headerlink\" title=\"4.sass/scss语法介绍\"></a>4.sass/scss语法介绍</h3><h4 id=\"变量\"><a href=\"#变量\" class=\"headerlink\" title=\"变量\"></a>变量</h4><p>变量用来存储需要在CSS中复用的信息，例如颜色和字体。SASS通过$符号去声明一个变量。<br><figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$color:#333;</span><br><span class=\"line\"><span class=\"selector-tag\">body</span>&#123;</span><br><span class=\"line\">    <span class=\"attribute\">color</span>:$color;</span><br><span class=\"line\">    <span class=\"attribute\">background</span>:$color;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>上面的将会转化为:<br><figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-tag\">body</span>&#123;</span><br><span class=\"line\">    <span class=\"attribute\">color</span>:<span class=\"number\">#333</span>;</span><br><span class=\"line\">    <span class=\"attribute\">background</span>:<span class=\"number\">#333</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"嵌套\"><a href=\"#嵌套\" class=\"headerlink\" title=\"嵌套\"></a>嵌套</h4><p>SASS允许开发人员以嵌套的方式使用CSS，但是过度的使用嵌套会让产生的CSS难以维护，因此是一种不好的实践，下面的例子表达了一个典型的网站导航样式<br><figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$normalColor:#f7f7f7</span><br><span class=\"line\"><span class=\"selector-tag\">nav</span> &#123;</span><br><span class=\"line\">    <span class=\"attribute\">width</span>:<span class=\"number\">100%</span>;</span><br><span class=\"line\">    ul &#123;</span><br><span class=\"line\">        <span class=\"selector-tag\">list-style</span><span class=\"selector-pseudo\">:none</span>;</span><br><span class=\"line\">        <span class=\"selector-tag\">li</span> &#123;</span><br><span class=\"line\">            <span class=\"attribute\">width</span>:<span class=\"number\">100%</span></span><br><span class=\"line\">            a &#123;</span><br><span class=\"line\">                color:$normalColor</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>上面代码将转为：<br><figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-tag\">nav</span> &#123;</span><br><span class=\"line\">    <span class=\"attribute\">width</span>:<span class=\"number\">100%</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"selector-tag\">nav</span> <span class=\"selector-tag\">ul</span> &#123;</span><br><span class=\"line\">    <span class=\"attribute\">list-style</span>:none;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"selector-tag\">nav</span> <span class=\"selector-tag\">ul</span> <span class=\"selector-tag\">li</span> &#123;</span><br><span class=\"line\">    <span class=\"attribute\">width</span>:<span class=\"number\">100%</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"selector-tag\">nav</span> <span class=\"selector-tag\">ul</span> <span class=\"selector-tag\">li</span> <span class=\"selector-tag\">a</span> &#123;</span><br><span class=\"line\">    <span class=\"attribute\">color</span>:<span class=\"number\">#f7f7f7</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"引入\"><a href=\"#引入\" class=\"headerlink\" title=\"引入\"></a>引入</h4><p>SASS能够将代码分割为多个片段，并以underscore风格的下划线作为其命名前缀（_partial.scss），SASS会通过这些下划线来辨别哪些文件是SASS片段，并且不让片段内容直接生成为CSS文件，从而只是在使用@import指令的位置被导入。CSS原生的@import会通过额外的HTTP请求获取引入的样式片段，而SASS的@import则会直接将这些引入的片段合并至当前CSS文件，并且不会产生新的HTTP请求。下面例子中的代码，将会在base.scss文件当中引入_reset.scss片断。<br><figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// _reset.scss</span><br><span class=\"line\"><span class=\"selector-tag\">html</span>, <span class=\"selector-tag\">body</span>, <span class=\"selector-tag\">ul</span>, <span class=\"selector-tag\">ol</span> &#123;</span><br><span class=\"line\">    <span class=\"attribute\">margin</span>:  <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"attribute\">padding</span>: <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// base.scss</span><br><span class=\"line\">@<span class=\"keyword\">import</span> <span class=\"string\">'reset'</span>;</span><br><span class=\"line\"><span class=\"selector-tag\">body</span> &#123;</span><br><span class=\"line\">    <span class=\"attribute\">font</span>: <span class=\"number\">100%</span> Helvetica, sans-serif;</span><br><span class=\"line\">    <span class=\"attribute\">background-color</span>: <span class=\"number\">#efefef</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>SASS中引入片断时，可以缺省使用文件扩展名，因此上面代码中直接通过@import ‘reset’引入，编译后生成的代码如下：<br><figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-tag\">html</span>, <span class=\"selector-tag\">body</span>, <span class=\"selector-tag\">ul</span>, <span class=\"selector-tag\">ol</span> &#123;</span><br><span class=\"line\">    <span class=\"attribute\">margin</span>: <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"attribute\">padding</span>: <span class=\"number\">0</span>; </span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"selector-tag\">body</span> &#123;</span><br><span class=\"line\">    <span class=\"attribute\">font</span>: <span class=\"number\">100%</span> Helvetica, sans-serif;</span><br><span class=\"line\">    <span class=\"attribute\">background-color</span>: <span class=\"number\">#efefef</span>; </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"混合\"><a href=\"#混合\" class=\"headerlink\" title=\"混合\"></a>混合</h4><p>混合（Mixin）用来分组那些需要在页面中复用的CSS声明，开发人员可以通过向Mixin传递变量参数来让代码更加灵活，该特性在添加浏览器兼容性前缀的时候非常有用，SASS目前使用@mixin name指令来进行混合操作。<br><figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@<span class=\"keyword\">mixin</span> border-radius($radius) &#123;</span><br><span class=\"line\">            border-radius: $radius;</span><br><span class=\"line\">        -ms-border-radius: $radius;</span><br><span class=\"line\">        -moz-border-radius: $radius;</span><br><span class=\"line\">    -webkit-border-radius: $radius;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"selector-class\">.box</span> &#123;</span><br><span class=\"line\">    @include border-radius(10px);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>上面的代码建立了一个名为border-radius的Mixin，并传递了一个变量$radius作为参数，然后在后续代码中通过@include border-radius(10px)使用该Mixin，最终编译的结果如下：<br><figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-class\">.box</span> &#123;</span><br><span class=\"line\">    <span class=\"attribute\">border-radius</span>: <span class=\"number\">10px</span>;</span><br><span class=\"line\">    <span class=\"attribute\">-ms-border-radius</span>: <span class=\"number\">10px</span>;</span><br><span class=\"line\">    <span class=\"attribute\">-moz-border-radius</span>: <span class=\"number\">10px</span>;</span><br><span class=\"line\">    <span class=\"attribute\">-webkit-border-radius</span>: <span class=\"number\">10px</span>; </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"继承\"><a href=\"#继承\" class=\"headerlink\" title=\"继承\"></a>继承</h4><p>继承是SASS中非常重要的一个特性，可以通过@extend指令在选择器之间复用CSS属性，并且不会产生冗余的代码，下面例子将会通过SASS提供的继承机制建立一系列样式：<br><figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 这段代码不会被输出到最终生成的CSS文件，因为它没有被任何代码所继承。</span><br><span class=\"line\">%<span class=\"selector-tag\">other-styles</span> &#123;</span><br><span class=\"line\">    <span class=\"attribute\">display</span>: flex;</span><br><span class=\"line\">    <span class=\"attribute\">flex-wrap</span>: wrap;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// 下面代码会正常输出到生成的CSS文件，因为它被其接下来的代码所继承。</span><br><span class=\"line\">%<span class=\"selector-tag\">message-common</span> &#123;</span><br><span class=\"line\">    <span class=\"attribute\">border</span>: <span class=\"number\">1px</span> solid <span class=\"number\">#ccc</span>;</span><br><span class=\"line\">    <span class=\"attribute\">padding</span>: <span class=\"number\">10px</span>;</span><br><span class=\"line\">    <span class=\"attribute\">color</span>: <span class=\"number\">#333</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"selector-class\">.message</span> &#123;</span><br><span class=\"line\">    @extend %message-common;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"selector-class\">.success</span> &#123;</span><br><span class=\"line\">    @extend %message-common;</span><br><span class=\"line\">    <span class=\"selector-tag\">border-color</span>: <span class=\"selector-tag\">green</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"selector-class\">.error</span> &#123;</span><br><span class=\"line\">    @extend %message-common;</span><br><span class=\"line\">    <span class=\"selector-tag\">border-color</span>: <span class=\"selector-tag\">red</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"selector-class\">.warning</span> &#123;</span><br><span class=\"line\">    @extend %message-common;</span><br><span class=\"line\">    <span class=\"selector-tag\">border-color</span>: <span class=\"selector-tag\">yellow</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>上面代码将.message中的CSS属性应用到了.success、.error、.warning上面，魔法将会发生在最终生成的CSS当中。这种方式能够避免在HTML元素上书写多个class选择器，最终生成的CSS样式是下面这样的：<br><figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-class\">.message</span>, <span class=\"selector-class\">.success</span>, <span class=\"selector-class\">.error</span>, <span class=\"selector-class\">.warning</span> &#123;</span><br><span class=\"line\">    <span class=\"attribute\">border</span>: <span class=\"number\">1px</span> solid <span class=\"number\">#ccc</span>;</span><br><span class=\"line\">    <span class=\"attribute\">padding</span>: <span class=\"number\">10px</span>;</span><br><span class=\"line\">    <span class=\"attribute\">color</span>: <span class=\"number\">#333</span>; </span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"selector-class\">.success</span> &#123;</span><br><span class=\"line\">    <span class=\"attribute\">border-color</span>: green; </span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"selector-class\">.error</span> &#123;</span><br><span class=\"line\">    <span class=\"attribute\">border-color</span>: red; </span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"selector-class\">.warning</span> &#123;</span><br><span class=\"line\">    <span class=\"attribute\">border-color</span>: yellow; </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"操作符\"><a href=\"#操作符\" class=\"headerlink\" title=\"操作符\"></a>操作符</h4><p>SASS提供了标准的算术运算符，例如+、-、*、/、%。在接下来的例子里，我们尝试在aside和article选择器当中对宽度进行简单的计算。<br><figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-class\">.container</span> &#123; <span class=\"attribute\">width</span>: <span class=\"number\">100%</span>; &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"selector-tag\">article</span><span class=\"selector-attr\">[role=\"main\"]</span> &#123;</span><br><span class=\"line\">    <span class=\"attribute\">float</span>: left;</span><br><span class=\"line\">    <span class=\"attribute\">width</span>: <span class=\"number\">600px</span> / <span class=\"number\">960px</span> * <span class=\"number\">100%</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"selector-tag\">aside</span><span class=\"selector-attr\">[role=\"complementary\"]</span> &#123;</span><br><span class=\"line\">    <span class=\"attribute\">float</span>: right;</span><br><span class=\"line\">    <span class=\"attribute\">width</span>: <span class=\"number\">300px</span> / <span class=\"number\">960px</span> * <span class=\"number\">100%</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>上面代码以960px为基准建立了简单的流式网格布局，SASS提供的算术运算符让开发人员可以更容易的将像素值转换为百分比，最终生成的CSS样式如下所示：<br><figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-class\">.container</span> &#123;</span><br><span class=\"line\">    <span class=\"attribute\">width</span>: <span class=\"number\">100%</span>; </span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"selector-tag\">article</span><span class=\"selector-attr\">[role=\"main\"]</span> &#123;</span><br><span class=\"line\">    <span class=\"attribute\">float</span>: left;</span><br><span class=\"line\">    <span class=\"attribute\">width</span>: <span class=\"number\">62.5%</span>; </span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"selector-tag\">aside</span><span class=\"selector-attr\">[role=\"complementary\"]</span> &#123;</span><br><span class=\"line\">    <span class=\"attribute\">float</span>: right;</span><br><span class=\"line\">    <span class=\"attribute\">width</span>: <span class=\"number\">31.25%</span>; </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"CSS扩展\"><a href=\"#CSS扩展\" class=\"headerlink\" title=\"CSS扩展\"></a>CSS扩展</h4><p>Scss使用”&amp;”关键字在CSS规则中引用父级选择器，例如在嵌套使用伪类选择器的场景下：<br><figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*===== SCSS =====*/</span></span><br><span class=\"line\">    <span class=\"selector-tag\">a</span> &#123;</span><br><span class=\"line\">        <span class=\"attribute\">font-weight</span>: bold;</span><br><span class=\"line\">        <span class=\"attribute\">text-decoration</span>: none;</span><br><span class=\"line\">        &amp;:hover &#123; text-decoration: underline; &#125;</span><br><span class=\"line\">        <span class=\"selector-tag\">body</span><span class=\"selector-class\">.firefox</span> &amp; &#123; <span class=\"attribute\">font-weight</span>: normal; &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/*===== CSS =====*/</span></span><br><span class=\"line\">    <span class=\"selector-tag\">a</span> &#123;</span><br><span class=\"line\">        <span class=\"attribute\">font-weight</span>: bold;</span><br><span class=\"line\">        <span class=\"attribute\">text-decoration</span>: none; </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"selector-tag\">a</span><span class=\"selector-pseudo\">:hover</span> &#123;</span><br><span class=\"line\">        <span class=\"attribute\">text-decoration</span>: underline;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"selector-tag\">body</span><span class=\"selector-class\">.firefox</span> <span class=\"selector-tag\">a</span> &#123;</span><br><span class=\"line\">        <span class=\"attribute\">font-weight</span>: normal; </span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure></p>\n<p>无论CSS规则嵌套的深度怎样，关键字”&amp;”都会使用父级选择器级联替换全部其出现的位置：<br><figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">    <span class=\"comment\">/*===== SCSS =====*/</span></span><br><span class=\"line\">    <span class=\"selector-id\">#main</span> &#123;</span><br><span class=\"line\">        <span class=\"attribute\">color</span>: black;</span><br><span class=\"line\">        a &#123;</span><br><span class=\"line\">            <span class=\"selector-tag\">font-weight</span>: <span class=\"selector-tag\">bold</span>;</span><br><span class=\"line\">            &amp;<span class=\"selector-pseudo\">:hover</span> &#123; <span class=\"attribute\">color</span>: red; &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/*===== CSS =====*/</span></span><br><span class=\"line\">    <span class=\"selector-id\">#main</span> &#123;</span><br><span class=\"line\">        <span class=\"attribute\">color</span>: black; </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"selector-id\">#main</span> <span class=\"selector-tag\">a</span> &#123;</span><br><span class=\"line\">        <span class=\"attribute\">font-weight</span>: bold; </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"selector-id\">#main</span> <span class=\"selector-tag\">a</span><span class=\"selector-pseudo\">:hover</span> &#123;</span><br><span class=\"line\">      <span class=\"attribute\">color</span>: red; </span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure></p>\n<p>“&amp;”必须出现在复合选择器开头的位置，后面再连接自定义的后缀，例如：<br><figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*===== SCSS =====*/</span></span><br><span class=\"line\"><span class=\"selector-id\">#main</span> &#123;</span><br><span class=\"line\">    <span class=\"attribute\">color</span>: black;</span><br><span class=\"line\">    &amp;-sidebar &#123; </span><br><span class=\"line\">        <span class=\"selector-tag\">border</span>: 1<span class=\"selector-tag\">px</span> <span class=\"selector-tag\">solid</span>; </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/*===== CSS =====*/</span></span><br><span class=\"line\"><span class=\"selector-id\">#main</span> &#123;</span><br><span class=\"line\">    <span class=\"attribute\">color</span>: black; </span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"selector-id\">#main-sidebar</span> &#123;</span><br><span class=\"line\">    <span class=\"attribute\">border</span>: <span class=\"number\">1px</span> solid; </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>如果在父级选择器不存在的场景使用&amp;，Scss预处理器会报出错误信息。</p>\n<h4 id=\"嵌套属性\"><a href=\"#嵌套属性\" class=\"headerlink\" title=\"嵌套属性\"></a>嵌套属性</h4><p>CSS许多属性都位于相同的命名空间（例如font-family、font-size、font-weight都位于font命名空间下），Scss当中只需要编写命名空间一次，后续嵌套的子属性都将会位于该命名空间之下，请看下面的代码：<br><figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*===== SCSS =====*/</span></span><br><span class=\"line\"><span class=\"selector-class\">.demo</span> &#123;</span><br><span class=\"line\">// 命令空间后带有冒号:</span><br><span class=\"line\">    <span class=\"selector-tag\">font</span>: &#123;</span><br><span class=\"line\">        <span class=\"attribute\">family</span>: fantasy;</span><br><span class=\"line\">        <span class=\"attribute\">size</span>: <span class=\"number\">30em</span>;</span><br><span class=\"line\">        <span class=\"attribute\">weight</span>: bold;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/*===== CSS =====*/</span></span><br><span class=\"line\"><span class=\"selector-class\">.demo</span> &#123;</span><br><span class=\"line\">    <span class=\"attribute\">font-family</span>: fantasy;</span><br><span class=\"line\">    <span class=\"attribute\">font-size</span>: <span class=\"number\">30em</span>;</span><br><span class=\"line\">    <span class=\"attribute\">font-weight</span>: bold; </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>命令空间上可以直接书写CSS简写属性，但是日常开发中建议直接书写CSS简写属性，尽量保持CSS语法的一致性。<br><figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-class\">.demo</span> &#123;</span><br><span class=\"line\">    <span class=\"attribute\">font</span>: <span class=\"number\">20px</span>/<span class=\"number\">24px</span> fantasy &#123;</span><br><span class=\"line\">        weight: bold;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"selector-class\">.demo</span> &#123;</span><br><span class=\"line\">    <span class=\"attribute\">font</span>: <span class=\"number\">20px</span>/<span class=\"number\">24px</span> fantasy;</span><br><span class=\"line\">        <span class=\"attribute\">font-weight</span>: bold;</span><br><span class=\"line\">    &#125;<span class=\"selector-tag\">sass</span></span><br></pre></td></tr></table></figure></p>\n<p>参考文章 <a href=\"https://www.jianshu.com/p/a99764ff3c41\" target=\"_blank\" rel=\"noopener\">简书</a></p>\n"},{"title":"promise使用","date":"2019-01-02T04:36:21.000Z","_content":"","source":"_posts/2019-01-02-promise使用.md","raw":"---\ntitle: promise使用\ndate: 2019-01-02 12:36:21\ntags:\n    \n---\n","slug":"2019-01-02-promise使用","published":1,"updated":"2019-03-05T14:53:25.566Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjtviomw9000bbtzie1te6e93","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"ES2015中class基本语法","date":"2019-01-29T09:29:17.000Z","_content":"\n### 类的由来\n\nJavaScript 语言中，生成实例对象的传统方法是通过构造函数。下面是一个例子\n\n```JavaScript\nfunction Point (x,y) {\n    this.x = x\n    this.y = y\n}\n\nPoint.prototype.toString = function () {\n    return '(' + this.x + ', ' + this.y + ')';\n}\n\nvar p = new Point(1,2)\n```\n\n上面这种写法跟传统的面向对象语言（比如 C++和 Java）差异很大，很容易让新学习这门语言的程序员感到困惑  \nES6 提供了更接近 \b 传统语言的写法，引入了 Class（类）这个概念，作为对象的模板。通过`class`关键词，可以定义类。  \n基本上，ES6`class`可以看做只是一个语法糖，他的绝大部分功能，ES5 都可以做到，新的`class`写法只是让对象原型的写法更加清晰、更像面向对象编程的语法而已。上面的代码用 ES6 的`class`改写，就是下面这样。\n\n```JavaScript\nclass Point {\n    constructor (x,y) {\n        this.x = x\n        this.y = y\n    }\n    toString () {\n        return '(' + this.x + ',' + this.y + ')'\n    }\n}\n```\n\n\b 上面代码定义了一个”类“，可以看到里面有一个`constructor`方法，这就是构造方法，而`this`关键词则代表实例对象。也就是说，ES5 的构造函数`Point`，对应 ES6 的`Point`类的构造方法。  \n`Point`类除了构造方法，还定义了一个`toString`方法。注意，定义”类“的方法的时候，前面不需要加上`function`这个关键字，直接把桉树定义放进去就可以了。另外，方法之间也不需要都好分隔，加了会报错。  \nES6 的类，完全可以看做构造函数的另一种方法。\n\n```JavaScript\nclass Point {\n    // ...\n}\ntypeof Point // \"function\"\nPoint === Point.prototype.constructor  // true\n```\n\n上面的代码表明，类的数据类型就是函数，类本身就指向构造函数。  \n使用的时候，也是直接对类使用`new`命令，跟构造函数的用法完全一致.\n\n```JavaScript\nclass Bar {\n    doStuff () {\n        console.log('stuff);\n    }\n}\n\nvar b = new Bar();\nb.doStuff()  // \"stuff\"\n```\n\n构造函数的`prototype`属性，在 ES6 的”类“上面继续存在。事实上，类的 \b 所有方法都定义在类的`prototype`属性上面。\n\n```JavaScript\nclass Point {\n    constructor () {\n        // ...\n    }\n\n    toString () {\n        // ...\n    }\n\n    toValue () {\n        // ...\n    }\n}\n\n// 等同于\n\nPoint.prototype = {\n    constructor () {},\n    toString () {},\n    toValue () {},\n}\n```\n\n在类的实例上面调用方法，其实就是调用原型上的方法。\n\n```JavaScript\nclass B {}\nlet b = new B()\nb.constructor === B.prototype.constructor  // true\n```\n\n上面代码中，`b`是`B`类的实例，它的`constructor`方法就是`B`类原型的`constructor`方法。  \n由于类的方法都定义在`prototype`对象上面，所以累的新方法可以添加在`prototype`对象上面。`Object.assign`方法可以很方便地一次向类添加多个方法。\n\n```JavaScript\nclass Point {\n    construtor () {\n        // ..\n    }\n}\nObject.assign(Point,prototype,{\n    toString () {},\n    toValue () {}\n});\n```\n\n`prototype`对象的`construtor`属性，直接指向”类“的本身，这与 ES5 的行为是一致。\n\n```JavaScript\nPoint.prototype.constructor === Point //true\n```\n\n另外，类的内部所有定义的方法，都是不可枚举的(non-enumerable)。\n\n```JavaScript\nclass Point {\n    constructor (x,y) {\n        // ...\n    }\n    toString () {\n        // ...\n    }\n}\n\nObject.keys(Point.prototype)\n// []\nObject.getOwnPropertyNames(Point.prototype)\n// [\"constructor\",\"toString\"]\n```\n\n上面代码中，`toString`方法是`Point`类内部定义的方法，它是不可枚举。这一点与 ES5 的行为不一致。\n\n```JavaScript\nvar Point = function (x,y) {\n    // ...\n}\nPoint.prototype.toString = function () {\n    // ...\n}\n\nObject.keys(Point.prototype)\n// [\"toString\"]\nObject.getOwnPropertyNames(Point.prototype)\n// [\"constructor\",\"toString\"]\n```\n\n\b 上面采用 ES5 的写法，`toString`方法就是可枚举的。\n\n### constuctor 方法\n\n`constructor`方法是类的默认方法，通过`new`命令生成的对象实例时，自动调用该方法。一个类必须有`constructor`方法，如果没有显示定义，一个空的`constructor`方法会被默认添加。\n\n```JavaScript\nclass Point {\n\n}\n//等同于\nclass Point {\n    constructor () {\n\n    }\n}\n```\n\n上面代码中，定义一个空的类`Point`，JavaScript 引擎会自动为它添加一个空的`construtor`方法。  \n`constructor`方法默认返回实例对象（\b 即`this`），完全可以指定返回另外一个对象。\n\n```JavaScript\nclass Foo {\n    constructor () {\n        return Object.create(null);\n    }\n}\n\nnew Foo() instanceof Foo\n// false\n```\n\n上面的代码中，`constructor`函数返回一个全新的对象，结果导致实例对象不是`Foo`类的实例。  \n类必须使用`new`调用，否则会报错。\b 这是它跟普通构造函数的一个主要区别，后者不用`new`也可以执行。\n\n```JavaScript\nclass Foo {\n    constructor () {\n        return Object.create(null)\n    }\n}\n\nFoo()\n// TypeError:Class constructor Foo cannot be invoked widthout 'new'\n```\n\n### 类的实例\n\n生成类的实例的写法，与 ES5 完全一样，也是使用`new`命令。前面说过，如果忘记加上`new`，像函数那样调用`Class`，将会报错。\n\n```JavaScript\nclass Point {\n    // ...\n}\n//报错\nvar point = Point(2,3);\n\n// 正确\nvar point = new Point(2,3)\n```\n\n与 ES5 一样，实例的属性除非显示定义在其本身（即定义在`this`对象上），否则都是定义在原型上（即定义在`class`上）。\n\n```JavaScript\n// 定义类\nclass Point {\n    constructor (x,y) {\n        this.x = x\n        this.y = y\n    }\n\n    toString () {\n        return '(' + this.x + ', ' + this.y + ')'\n    }\n}\nvar point = new Point(2,3)\npoint.toString() //(2,3)\npoint.hasOwnProperty('x') // true\npoint.hasOwnProperty('y') // true\npoint.hasOwnProperty('toString') // false\npoint.__proto__.hasOwnProperty('toString') //true\n```\n\n上面代码中,`x`和`y`都是实例对象`point`自身的属性（因为定义在`this`变量上），所以`hasOwnProperty`方法返回`true`，而`toString`是原型对象的属性（因为定义在`point`类是哪个），所以`hasOwnProperty`方法返回`false`。这些都与 ES5 的行为保持一致。  \n与 ES5 一样，类的所有实例都共享一个原型对象。\n\n```JavaScript\nvar p1 = new Point(2,3)\nvar p2 = new Point(3,2)\np1.__proto__ === p2.__proto__\n// true\n```\n","source":"_posts/2019-01-29-ES2015中class基本语法.md","raw":"---\ntitle: ES2015中class基本语法\ndate: 2019-01-29 17:29:17\ntags:\n    -ES6\n---\n\n### 类的由来\n\nJavaScript 语言中，生成实例对象的传统方法是通过构造函数。下面是一个例子\n\n```JavaScript\nfunction Point (x,y) {\n    this.x = x\n    this.y = y\n}\n\nPoint.prototype.toString = function () {\n    return '(' + this.x + ', ' + this.y + ')';\n}\n\nvar p = new Point(1,2)\n```\n\n上面这种写法跟传统的面向对象语言（比如 C++和 Java）差异很大，很容易让新学习这门语言的程序员感到困惑  \nES6 提供了更接近 \b 传统语言的写法，引入了 Class（类）这个概念，作为对象的模板。通过`class`关键词，可以定义类。  \n基本上，ES6`class`可以看做只是一个语法糖，他的绝大部分功能，ES5 都可以做到，新的`class`写法只是让对象原型的写法更加清晰、更像面向对象编程的语法而已。上面的代码用 ES6 的`class`改写，就是下面这样。\n\n```JavaScript\nclass Point {\n    constructor (x,y) {\n        this.x = x\n        this.y = y\n    }\n    toString () {\n        return '(' + this.x + ',' + this.y + ')'\n    }\n}\n```\n\n\b 上面代码定义了一个”类“，可以看到里面有一个`constructor`方法，这就是构造方法，而`this`关键词则代表实例对象。也就是说，ES5 的构造函数`Point`，对应 ES6 的`Point`类的构造方法。  \n`Point`类除了构造方法，还定义了一个`toString`方法。注意，定义”类“的方法的时候，前面不需要加上`function`这个关键字，直接把桉树定义放进去就可以了。另外，方法之间也不需要都好分隔，加了会报错。  \nES6 的类，完全可以看做构造函数的另一种方法。\n\n```JavaScript\nclass Point {\n    // ...\n}\ntypeof Point // \"function\"\nPoint === Point.prototype.constructor  // true\n```\n\n上面的代码表明，类的数据类型就是函数，类本身就指向构造函数。  \n使用的时候，也是直接对类使用`new`命令，跟构造函数的用法完全一致.\n\n```JavaScript\nclass Bar {\n    doStuff () {\n        console.log('stuff);\n    }\n}\n\nvar b = new Bar();\nb.doStuff()  // \"stuff\"\n```\n\n构造函数的`prototype`属性，在 ES6 的”类“上面继续存在。事实上，类的 \b 所有方法都定义在类的`prototype`属性上面。\n\n```JavaScript\nclass Point {\n    constructor () {\n        // ...\n    }\n\n    toString () {\n        // ...\n    }\n\n    toValue () {\n        // ...\n    }\n}\n\n// 等同于\n\nPoint.prototype = {\n    constructor () {},\n    toString () {},\n    toValue () {},\n}\n```\n\n在类的实例上面调用方法，其实就是调用原型上的方法。\n\n```JavaScript\nclass B {}\nlet b = new B()\nb.constructor === B.prototype.constructor  // true\n```\n\n上面代码中，`b`是`B`类的实例，它的`constructor`方法就是`B`类原型的`constructor`方法。  \n由于类的方法都定义在`prototype`对象上面，所以累的新方法可以添加在`prototype`对象上面。`Object.assign`方法可以很方便地一次向类添加多个方法。\n\n```JavaScript\nclass Point {\n    construtor () {\n        // ..\n    }\n}\nObject.assign(Point,prototype,{\n    toString () {},\n    toValue () {}\n});\n```\n\n`prototype`对象的`construtor`属性，直接指向”类“的本身，这与 ES5 的行为是一致。\n\n```JavaScript\nPoint.prototype.constructor === Point //true\n```\n\n另外，类的内部所有定义的方法，都是不可枚举的(non-enumerable)。\n\n```JavaScript\nclass Point {\n    constructor (x,y) {\n        // ...\n    }\n    toString () {\n        // ...\n    }\n}\n\nObject.keys(Point.prototype)\n// []\nObject.getOwnPropertyNames(Point.prototype)\n// [\"constructor\",\"toString\"]\n```\n\n上面代码中，`toString`方法是`Point`类内部定义的方法，它是不可枚举。这一点与 ES5 的行为不一致。\n\n```JavaScript\nvar Point = function (x,y) {\n    // ...\n}\nPoint.prototype.toString = function () {\n    // ...\n}\n\nObject.keys(Point.prototype)\n// [\"toString\"]\nObject.getOwnPropertyNames(Point.prototype)\n// [\"constructor\",\"toString\"]\n```\n\n\b 上面采用 ES5 的写法，`toString`方法就是可枚举的。\n\n### constuctor 方法\n\n`constructor`方法是类的默认方法，通过`new`命令生成的对象实例时，自动调用该方法。一个类必须有`constructor`方法，如果没有显示定义，一个空的`constructor`方法会被默认添加。\n\n```JavaScript\nclass Point {\n\n}\n//等同于\nclass Point {\n    constructor () {\n\n    }\n}\n```\n\n上面代码中，定义一个空的类`Point`，JavaScript 引擎会自动为它添加一个空的`construtor`方法。  \n`constructor`方法默认返回实例对象（\b 即`this`），完全可以指定返回另外一个对象。\n\n```JavaScript\nclass Foo {\n    constructor () {\n        return Object.create(null);\n    }\n}\n\nnew Foo() instanceof Foo\n// false\n```\n\n上面的代码中，`constructor`函数返回一个全新的对象，结果导致实例对象不是`Foo`类的实例。  \n类必须使用`new`调用，否则会报错。\b 这是它跟普通构造函数的一个主要区别，后者不用`new`也可以执行。\n\n```JavaScript\nclass Foo {\n    constructor () {\n        return Object.create(null)\n    }\n}\n\nFoo()\n// TypeError:Class constructor Foo cannot be invoked widthout 'new'\n```\n\n### 类的实例\n\n生成类的实例的写法，与 ES5 完全一样，也是使用`new`命令。前面说过，如果忘记加上`new`，像函数那样调用`Class`，将会报错。\n\n```JavaScript\nclass Point {\n    // ...\n}\n//报错\nvar point = Point(2,3);\n\n// 正确\nvar point = new Point(2,3)\n```\n\n与 ES5 一样，实例的属性除非显示定义在其本身（即定义在`this`对象上），否则都是定义在原型上（即定义在`class`上）。\n\n```JavaScript\n// 定义类\nclass Point {\n    constructor (x,y) {\n        this.x = x\n        this.y = y\n    }\n\n    toString () {\n        return '(' + this.x + ', ' + this.y + ')'\n    }\n}\nvar point = new Point(2,3)\npoint.toString() //(2,3)\npoint.hasOwnProperty('x') // true\npoint.hasOwnProperty('y') // true\npoint.hasOwnProperty('toString') // false\npoint.__proto__.hasOwnProperty('toString') //true\n```\n\n上面代码中,`x`和`y`都是实例对象`point`自身的属性（因为定义在`this`变量上），所以`hasOwnProperty`方法返回`true`，而`toString`是原型对象的属性（因为定义在`point`类是哪个），所以`hasOwnProperty`方法返回`false`。这些都与 ES5 的行为保持一致。  \n与 ES5 一样，类的所有实例都共享一个原型对象。\n\n```JavaScript\nvar p1 = new Point(2,3)\nvar p2 = new Point(3,2)\np1.__proto__ === p2.__proto__\n// true\n```\n","slug":"2019-01-29-ES2015中class基本语法","published":1,"updated":"2019-03-05T14:52:37.233Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjtviomwd000ebtzih7bwilw1","content":"<h3 id=\"类的由来\"><a href=\"#类的由来\" class=\"headerlink\" title=\"类的由来\"></a>类的由来</h3><p>JavaScript 语言中，生成实例对象的传统方法是通过构造函数。下面是一个例子</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Point</span> (<span class=\"params\">x,y</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.x = x</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.y = y</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">Point.prototype.toString = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">'('</span> + <span class=\"keyword\">this</span>.x + <span class=\"string\">', '</span> + <span class=\"keyword\">this</span>.y + <span class=\"string\">')'</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> p = <span class=\"keyword\">new</span> Point(<span class=\"number\">1</span>,<span class=\"number\">2</span>)</span><br></pre></td></tr></table></figure>\n<p>上面这种写法跟传统的面向对象语言（比如 C++和 Java）差异很大，很容易让新学习这门语言的程序员感到困惑<br>ES6 提供了更接近 \b 传统语言的写法，引入了 Class（类）这个概念，作为对象的模板。通过<code>class</code>关键词，可以定义类。<br>基本上，ES6<code>class</code>可以看做只是一个语法糖，他的绝大部分功能，ES5 都可以做到，新的<code>class</code>写法只是让对象原型的写法更加清晰、更像面向对象编程的语法而已。上面的代码用 ES6 的<code>class</code>改写，就是下面这样。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Point</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">constructor</span> (x,y) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.x = x</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.y = y</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    toString () &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">'('</span> + <span class=\"keyword\">this</span>.x + <span class=\"string\">','</span> + <span class=\"keyword\">this</span>.y + <span class=\"string\">')'</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>\b 上面代码定义了一个”类“，可以看到里面有一个<code>constructor</code>方法，这就是构造方法，而<code>this</code>关键词则代表实例对象。也就是说，ES5 的构造函数<code>Point</code>，对应 ES6 的<code>Point</code>类的构造方法。<br><code>Point</code>类除了构造方法，还定义了一个<code>toString</code>方法。注意，定义”类“的方法的时候，前面不需要加上<code>function</code>这个关键字，直接把桉树定义放进去就可以了。另外，方法之间也不需要都好分隔，加了会报错。<br>ES6 的类，完全可以看做构造函数的另一种方法。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Point</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// ...</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">typeof</span> Point <span class=\"comment\">// \"function\"</span></span><br><span class=\"line\">Point === Point.prototype.constructor  <span class=\"comment\">// true</span></span><br></pre></td></tr></table></figure>\n<p>上面的代码表明，类的数据类型就是函数，类本身就指向构造函数。<br>使用的时候，也是直接对类使用<code>new</code>命令，跟构造函数的用法完全一致.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Bar</span> </span>&#123;</span><br><span class=\"line\">    doStuff () &#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"string\">'stuff);</span></span><br><span class=\"line\"><span class=\"string\">    &#125;</span></span><br><span class=\"line\"><span class=\"string\">&#125;</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">var b = new Bar();</span></span><br><span class=\"line\"><span class=\"string\">b.doStuff()  // \"stuff\"</span></span><br></pre></td></tr></table></figure>\n<p>构造函数的<code>prototype</code>属性，在 ES6 的”类“上面继续存在。事实上，类的 \b 所有方法都定义在类的<code>prototype</code>属性上面。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Point</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">constructor</span> () &#123;</span><br><span class=\"line\">        <span class=\"comment\">// ...</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    toString () &#123;</span><br><span class=\"line\">        <span class=\"comment\">// ...</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    toValue () &#123;</span><br><span class=\"line\">        <span class=\"comment\">// ...</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 等同于</span></span><br><span class=\"line\"></span><br><span class=\"line\">Point.prototype = &#123;</span><br><span class=\"line\">    <span class=\"keyword\">constructor</span> () &#123;&#125;,</span><br><span class=\"line\">    toString () &#123;&#125;,</span><br><span class=\"line\">    toValue () &#123;&#125;,</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>在类的实例上面调用方法，其实就是调用原型上的方法。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">B</span> </span>&#123;&#125;</span><br><span class=\"line\"><span class=\"keyword\">let</span> b = <span class=\"keyword\">new</span> B()</span><br><span class=\"line\">b.constructor === B.prototype.constructor  <span class=\"comment\">// true</span></span><br></pre></td></tr></table></figure>\n<p>上面代码中，<code>b</code>是<code>B</code>类的实例，它的<code>constructor</code>方法就是<code>B</code>类原型的<code>constructor</code>方法。<br>由于类的方法都定义在<code>prototype</code>对象上面，所以累的新方法可以添加在<code>prototype</code>对象上面。<code>Object.assign</code>方法可以很方便地一次向类添加多个方法。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Point</span> </span>&#123;</span><br><span class=\"line\">    construtor () &#123;</span><br><span class=\"line\">        <span class=\"comment\">// ..</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"built_in\">Object</span>.assign(Point,prototype,&#123;</span><br><span class=\"line\">    toString () &#123;&#125;,</span><br><span class=\"line\">    toValue () &#123;&#125;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p><code>prototype</code>对象的<code>construtor</code>属性，直接指向”类“的本身，这与 ES5 的行为是一致。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Point.prototype.constructor === Point <span class=\"comment\">//true</span></span><br></pre></td></tr></table></figure>\n<p>另外，类的内部所有定义的方法，都是不可枚举的(non-enumerable)。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Point</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">constructor</span> (x,y) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// ...</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    toString () &#123;</span><br><span class=\"line\">        <span class=\"comment\">// ...</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">Object</span>.keys(Point.prototype)</span><br><span class=\"line\"><span class=\"comment\">// []</span></span><br><span class=\"line\"><span class=\"built_in\">Object</span>.getOwnPropertyNames(Point.prototype)</span><br><span class=\"line\"><span class=\"comment\">// [\"constructor\",\"toString\"]</span></span><br></pre></td></tr></table></figure>\n<p>上面代码中，<code>toString</code>方法是<code>Point</code>类内部定义的方法，它是不可枚举。这一点与 ES5 的行为不一致。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> Point = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">x,y</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// ...</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\">Point.prototype.toString = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// ...</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">Object</span>.keys(Point.prototype)</span><br><span class=\"line\"><span class=\"comment\">// [\"toString\"]</span></span><br><span class=\"line\"><span class=\"built_in\">Object</span>.getOwnPropertyNames(Point.prototype)</span><br><span class=\"line\"><span class=\"comment\">// [\"constructor\",\"toString\"]</span></span><br></pre></td></tr></table></figure>\n<p>\b 上面采用 ES5 的写法，<code>toString</code>方法就是可枚举的。</p>\n<h3 id=\"constuctor-方法\"><a href=\"#constuctor-方法\" class=\"headerlink\" title=\"constuctor 方法\"></a>constuctor 方法</h3><p><code>constructor</code>方法是类的默认方法，通过<code>new</code>命令生成的对象实例时，自动调用该方法。一个类必须有<code>constructor</code>方法，如果没有显示定义，一个空的<code>constructor</code>方法会被默认添加。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Point</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//等同于</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Point</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">constructor</span> () &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>上面代码中，定义一个空的类<code>Point</code>，JavaScript 引擎会自动为它添加一个空的<code>construtor</code>方法。<br><code>constructor</code>方法默认返回实例对象（\b 即<code>this</code>），完全可以指定返回另外一个对象。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Foo</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">constructor</span> () &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"built_in\">Object</span>.create(<span class=\"literal\">null</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">new</span> Foo() <span class=\"keyword\">instanceof</span> Foo</span><br><span class=\"line\"><span class=\"comment\">// false</span></span><br></pre></td></tr></table></figure>\n<p>上面的代码中，<code>constructor</code>函数返回一个全新的对象，结果导致实例对象不是<code>Foo</code>类的实例。<br>类必须使用<code>new</code>调用，否则会报错。\b 这是它跟普通构造函数的一个主要区别，后者不用<code>new</code>也可以执行。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Foo</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">constructor</span> () &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"built_in\">Object</span>.create(<span class=\"literal\">null</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">Foo()</span><br><span class=\"line\"><span class=\"comment\">// TypeError:Class constructor Foo cannot be invoked widthout 'new'</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"类的实例\"><a href=\"#类的实例\" class=\"headerlink\" title=\"类的实例\"></a>类的实例</h3><p>生成类的实例的写法，与 ES5 完全一样，也是使用<code>new</code>命令。前面说过，如果忘记加上<code>new</code>，像函数那样调用<code>Class</code>，将会报错。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Point</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// ...</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//报错</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> point = Point(<span class=\"number\">2</span>,<span class=\"number\">3</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 正确</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> point = <span class=\"keyword\">new</span> Point(<span class=\"number\">2</span>,<span class=\"number\">3</span>)</span><br></pre></td></tr></table></figure>\n<p>与 ES5 一样，实例的属性除非显示定义在其本身（即定义在<code>this</code>对象上），否则都是定义在原型上（即定义在<code>class</code>上）。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 定义类</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Point</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">constructor</span> (x,y) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.x = x</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.y = y</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    toString () &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">'('</span> + <span class=\"keyword\">this</span>.x + <span class=\"string\">', '</span> + <span class=\"keyword\">this</span>.y + <span class=\"string\">')'</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> point = <span class=\"keyword\">new</span> Point(<span class=\"number\">2</span>,<span class=\"number\">3</span>)</span><br><span class=\"line\">point.toString() <span class=\"comment\">//(2,3)</span></span><br><span class=\"line\">point.hasOwnProperty(<span class=\"string\">'x'</span>) <span class=\"comment\">// true</span></span><br><span class=\"line\">point.hasOwnProperty(<span class=\"string\">'y'</span>) <span class=\"comment\">// true</span></span><br><span class=\"line\">point.hasOwnProperty(<span class=\"string\">'toString'</span>) <span class=\"comment\">// false</span></span><br><span class=\"line\">point.__proto__.hasOwnProperty(<span class=\"string\">'toString'</span>) <span class=\"comment\">//true</span></span><br></pre></td></tr></table></figure>\n<p>上面代码中,<code>x</code>和<code>y</code>都是实例对象<code>point</code>自身的属性（因为定义在<code>this</code>变量上），所以<code>hasOwnProperty</code>方法返回<code>true</code>，而<code>toString</code>是原型对象的属性（因为定义在<code>point</code>类是哪个），所以<code>hasOwnProperty</code>方法返回<code>false</code>。这些都与 ES5 的行为保持一致。<br>与 ES5 一样，类的所有实例都共享一个原型对象。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> p1 = <span class=\"keyword\">new</span> Point(<span class=\"number\">2</span>,<span class=\"number\">3</span>)</span><br><span class=\"line\"><span class=\"keyword\">var</span> p2 = <span class=\"keyword\">new</span> Point(<span class=\"number\">3</span>,<span class=\"number\">2</span>)</span><br><span class=\"line\">p1.__proto__ === p2.__proto__</span><br><span class=\"line\"><span class=\"comment\">// true</span></span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"类的由来\"><a href=\"#类的由来\" class=\"headerlink\" title=\"类的由来\"></a>类的由来</h3><p>JavaScript 语言中，生成实例对象的传统方法是通过构造函数。下面是一个例子</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Point</span> (<span class=\"params\">x,y</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.x = x</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.y = y</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">Point.prototype.toString = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">'('</span> + <span class=\"keyword\">this</span>.x + <span class=\"string\">', '</span> + <span class=\"keyword\">this</span>.y + <span class=\"string\">')'</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> p = <span class=\"keyword\">new</span> Point(<span class=\"number\">1</span>,<span class=\"number\">2</span>)</span><br></pre></td></tr></table></figure>\n<p>上面这种写法跟传统的面向对象语言（比如 C++和 Java）差异很大，很容易让新学习这门语言的程序员感到困惑<br>ES6 提供了更接近 \b 传统语言的写法，引入了 Class（类）这个概念，作为对象的模板。通过<code>class</code>关键词，可以定义类。<br>基本上，ES6<code>class</code>可以看做只是一个语法糖，他的绝大部分功能，ES5 都可以做到，新的<code>class</code>写法只是让对象原型的写法更加清晰、更像面向对象编程的语法而已。上面的代码用 ES6 的<code>class</code>改写，就是下面这样。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Point</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">constructor</span> (x,y) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.x = x</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.y = y</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    toString () &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">'('</span> + <span class=\"keyword\">this</span>.x + <span class=\"string\">','</span> + <span class=\"keyword\">this</span>.y + <span class=\"string\">')'</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>\b 上面代码定义了一个”类“，可以看到里面有一个<code>constructor</code>方法，这就是构造方法，而<code>this</code>关键词则代表实例对象。也就是说，ES5 的构造函数<code>Point</code>，对应 ES6 的<code>Point</code>类的构造方法。<br><code>Point</code>类除了构造方法，还定义了一个<code>toString</code>方法。注意，定义”类“的方法的时候，前面不需要加上<code>function</code>这个关键字，直接把桉树定义放进去就可以了。另外，方法之间也不需要都好分隔，加了会报错。<br>ES6 的类，完全可以看做构造函数的另一种方法。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Point</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// ...</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">typeof</span> Point <span class=\"comment\">// \"function\"</span></span><br><span class=\"line\">Point === Point.prototype.constructor  <span class=\"comment\">// true</span></span><br></pre></td></tr></table></figure>\n<p>上面的代码表明，类的数据类型就是函数，类本身就指向构造函数。<br>使用的时候，也是直接对类使用<code>new</code>命令，跟构造函数的用法完全一致.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Bar</span> </span>&#123;</span><br><span class=\"line\">    doStuff () &#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"string\">'stuff);</span></span><br><span class=\"line\"><span class=\"string\">    &#125;</span></span><br><span class=\"line\"><span class=\"string\">&#125;</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">var b = new Bar();</span></span><br><span class=\"line\"><span class=\"string\">b.doStuff()  // \"stuff\"</span></span><br></pre></td></tr></table></figure>\n<p>构造函数的<code>prototype</code>属性，在 ES6 的”类“上面继续存在。事实上，类的 \b 所有方法都定义在类的<code>prototype</code>属性上面。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Point</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">constructor</span> () &#123;</span><br><span class=\"line\">        <span class=\"comment\">// ...</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    toString () &#123;</span><br><span class=\"line\">        <span class=\"comment\">// ...</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    toValue () &#123;</span><br><span class=\"line\">        <span class=\"comment\">// ...</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 等同于</span></span><br><span class=\"line\"></span><br><span class=\"line\">Point.prototype = &#123;</span><br><span class=\"line\">    <span class=\"keyword\">constructor</span> () &#123;&#125;,</span><br><span class=\"line\">    toString () &#123;&#125;,</span><br><span class=\"line\">    toValue () &#123;&#125;,</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>在类的实例上面调用方法，其实就是调用原型上的方法。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">B</span> </span>&#123;&#125;</span><br><span class=\"line\"><span class=\"keyword\">let</span> b = <span class=\"keyword\">new</span> B()</span><br><span class=\"line\">b.constructor === B.prototype.constructor  <span class=\"comment\">// true</span></span><br></pre></td></tr></table></figure>\n<p>上面代码中，<code>b</code>是<code>B</code>类的实例，它的<code>constructor</code>方法就是<code>B</code>类原型的<code>constructor</code>方法。<br>由于类的方法都定义在<code>prototype</code>对象上面，所以累的新方法可以添加在<code>prototype</code>对象上面。<code>Object.assign</code>方法可以很方便地一次向类添加多个方法。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Point</span> </span>&#123;</span><br><span class=\"line\">    construtor () &#123;</span><br><span class=\"line\">        <span class=\"comment\">// ..</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"built_in\">Object</span>.assign(Point,prototype,&#123;</span><br><span class=\"line\">    toString () &#123;&#125;,</span><br><span class=\"line\">    toValue () &#123;&#125;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p><code>prototype</code>对象的<code>construtor</code>属性，直接指向”类“的本身，这与 ES5 的行为是一致。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Point.prototype.constructor === Point <span class=\"comment\">//true</span></span><br></pre></td></tr></table></figure>\n<p>另外，类的内部所有定义的方法，都是不可枚举的(non-enumerable)。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Point</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">constructor</span> (x,y) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// ...</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    toString () &#123;</span><br><span class=\"line\">        <span class=\"comment\">// ...</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">Object</span>.keys(Point.prototype)</span><br><span class=\"line\"><span class=\"comment\">// []</span></span><br><span class=\"line\"><span class=\"built_in\">Object</span>.getOwnPropertyNames(Point.prototype)</span><br><span class=\"line\"><span class=\"comment\">// [\"constructor\",\"toString\"]</span></span><br></pre></td></tr></table></figure>\n<p>上面代码中，<code>toString</code>方法是<code>Point</code>类内部定义的方法，它是不可枚举。这一点与 ES5 的行为不一致。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> Point = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">x,y</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// ...</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\">Point.prototype.toString = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// ...</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">Object</span>.keys(Point.prototype)</span><br><span class=\"line\"><span class=\"comment\">// [\"toString\"]</span></span><br><span class=\"line\"><span class=\"built_in\">Object</span>.getOwnPropertyNames(Point.prototype)</span><br><span class=\"line\"><span class=\"comment\">// [\"constructor\",\"toString\"]</span></span><br></pre></td></tr></table></figure>\n<p>\b 上面采用 ES5 的写法，<code>toString</code>方法就是可枚举的。</p>\n<h3 id=\"constuctor-方法\"><a href=\"#constuctor-方法\" class=\"headerlink\" title=\"constuctor 方法\"></a>constuctor 方法</h3><p><code>constructor</code>方法是类的默认方法，通过<code>new</code>命令生成的对象实例时，自动调用该方法。一个类必须有<code>constructor</code>方法，如果没有显示定义，一个空的<code>constructor</code>方法会被默认添加。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Point</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//等同于</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Point</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">constructor</span> () &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>上面代码中，定义一个空的类<code>Point</code>，JavaScript 引擎会自动为它添加一个空的<code>construtor</code>方法。<br><code>constructor</code>方法默认返回实例对象（\b 即<code>this</code>），完全可以指定返回另外一个对象。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Foo</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">constructor</span> () &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"built_in\">Object</span>.create(<span class=\"literal\">null</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">new</span> Foo() <span class=\"keyword\">instanceof</span> Foo</span><br><span class=\"line\"><span class=\"comment\">// false</span></span><br></pre></td></tr></table></figure>\n<p>上面的代码中，<code>constructor</code>函数返回一个全新的对象，结果导致实例对象不是<code>Foo</code>类的实例。<br>类必须使用<code>new</code>调用，否则会报错。\b 这是它跟普通构造函数的一个主要区别，后者不用<code>new</code>也可以执行。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Foo</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">constructor</span> () &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"built_in\">Object</span>.create(<span class=\"literal\">null</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">Foo()</span><br><span class=\"line\"><span class=\"comment\">// TypeError:Class constructor Foo cannot be invoked widthout 'new'</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"类的实例\"><a href=\"#类的实例\" class=\"headerlink\" title=\"类的实例\"></a>类的实例</h3><p>生成类的实例的写法，与 ES5 完全一样，也是使用<code>new</code>命令。前面说过，如果忘记加上<code>new</code>，像函数那样调用<code>Class</code>，将会报错。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Point</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// ...</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//报错</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> point = Point(<span class=\"number\">2</span>,<span class=\"number\">3</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 正确</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> point = <span class=\"keyword\">new</span> Point(<span class=\"number\">2</span>,<span class=\"number\">3</span>)</span><br></pre></td></tr></table></figure>\n<p>与 ES5 一样，实例的属性除非显示定义在其本身（即定义在<code>this</code>对象上），否则都是定义在原型上（即定义在<code>class</code>上）。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 定义类</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Point</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">constructor</span> (x,y) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.x = x</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.y = y</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    toString () &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">'('</span> + <span class=\"keyword\">this</span>.x + <span class=\"string\">', '</span> + <span class=\"keyword\">this</span>.y + <span class=\"string\">')'</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> point = <span class=\"keyword\">new</span> Point(<span class=\"number\">2</span>,<span class=\"number\">3</span>)</span><br><span class=\"line\">point.toString() <span class=\"comment\">//(2,3)</span></span><br><span class=\"line\">point.hasOwnProperty(<span class=\"string\">'x'</span>) <span class=\"comment\">// true</span></span><br><span class=\"line\">point.hasOwnProperty(<span class=\"string\">'y'</span>) <span class=\"comment\">// true</span></span><br><span class=\"line\">point.hasOwnProperty(<span class=\"string\">'toString'</span>) <span class=\"comment\">// false</span></span><br><span class=\"line\">point.__proto__.hasOwnProperty(<span class=\"string\">'toString'</span>) <span class=\"comment\">//true</span></span><br></pre></td></tr></table></figure>\n<p>上面代码中,<code>x</code>和<code>y</code>都是实例对象<code>point</code>自身的属性（因为定义在<code>this</code>变量上），所以<code>hasOwnProperty</code>方法返回<code>true</code>，而<code>toString</code>是原型对象的属性（因为定义在<code>point</code>类是哪个），所以<code>hasOwnProperty</code>方法返回<code>false</code>。这些都与 ES5 的行为保持一致。<br>与 ES5 一样，类的所有实例都共享一个原型对象。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> p1 = <span class=\"keyword\">new</span> Point(<span class=\"number\">2</span>,<span class=\"number\">3</span>)</span><br><span class=\"line\"><span class=\"keyword\">var</span> p2 = <span class=\"keyword\">new</span> Point(<span class=\"number\">3</span>,<span class=\"number\">2</span>)</span><br><span class=\"line\">p1.__proto__ === p2.__proto__</span><br><span class=\"line\"><span class=\"comment\">// true</span></span><br></pre></td></tr></table></figure>\n"},{"title":"JavaScript中this指向问题（含ES6）","date":"2019-01-31T02:36:54.000Z","_content":"","source":"_posts/2019-01-31-JavaScript中this指向问题（含ES6）.md","raw":"---\ntitle: JavaScript中this指向问题（含ES6）\ndate: 2019-01-31 10:36:54\ntags:\n---\n","slug":"2019-01-31-JavaScript中this指向问题（含ES6）","published":1,"updated":"2019-03-05T14:52:55.544Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjtviomwe000gbtzimc55wdcc","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"JavaScript中的原型链","date":"2019-01-31T01:54:26.000Z","_content":"\n#### JavaScript 对象的创建方式\n\n在 JavaScript 中，创建对象的方式包括两种：\b  \n1、对象字面量  \n2、使用`new`表达式  \n对象字面量是一种灵活方便的书写方式，例如:\n\n```JavaScript\nvar point = {\n    p:'test',\n    alertP:function () {\n        alert(this.p);\n    }\n}\n```\n\n这样就用对象字面量创建了一个对象 p，它具有一个成员变量以及一个 \b 成员方法 \b`alertP`。这种写法不需要定义构造函数，因此不在本文讨论范围之内。这种写法的缺点是，每创建一个 \b 新的对象都需要写出完整的定义语句，不便于创建大量相同类型的 \b 对象，不利于继承等高级特性。\n\nnew 表达式是配合构造函数使用的，例如`new String('a string')`，调用内置的`String`函数构造一个字符串对象。下面我们用构造函数的方式来重新创建一个实现同样功能的对象，首先是定义构造函数，然后是用调用`new`表达式:\n\n```JavaScript\nfunction point () {\n    this.p = 'test';\n    this.alertP = function () {\n        alert(this.p);\n    }\n}\n\nvar point2 = new point();\n```\n\n那么，在使用`new`操作符来调用一个构造函数的时候，发生了什么了呢？其实很简单，就发生了四件事：\n\n```JavaScript\nvar obj = {};\nobj.__proto__ = point.prototype;\npoint.call(obj);\nreturn obj;\n```\n第一行，创建一个空的对象`obj`   \n第二行，将这个对象的`__proto__`成员指向了构造函数对象的`prototype`成员对象，这是最关键的异步，具体细节将在下文描述。    \n第三行，将构造函数的\b作用域赋给新对象，因此`point`函数中的`this`指向新对象`obj`，然后调用`point`。于是我们就给`0bj`对象赋值了一个成员变量`p`，这个成员变量的值就是`'test'`\n","source":"_posts/2019-01-31-JavaScript中的原型链.md","raw":"---\ntitle: JavaScript中的原型链\ndate: 2019-01-31 09:54:26\ntags:\n---\n\n#### JavaScript 对象的创建方式\n\n在 JavaScript 中，创建对象的方式包括两种：\b  \n1、对象字面量  \n2、使用`new`表达式  \n对象字面量是一种灵活方便的书写方式，例如:\n\n```JavaScript\nvar point = {\n    p:'test',\n    alertP:function () {\n        alert(this.p);\n    }\n}\n```\n\n这样就用对象字面量创建了一个对象 p，它具有一个成员变量以及一个 \b 成员方法 \b`alertP`。这种写法不需要定义构造函数，因此不在本文讨论范围之内。这种写法的缺点是，每创建一个 \b 新的对象都需要写出完整的定义语句，不便于创建大量相同类型的 \b 对象，不利于继承等高级特性。\n\nnew 表达式是配合构造函数使用的，例如`new String('a string')`，调用内置的`String`函数构造一个字符串对象。下面我们用构造函数的方式来重新创建一个实现同样功能的对象，首先是定义构造函数，然后是用调用`new`表达式:\n\n```JavaScript\nfunction point () {\n    this.p = 'test';\n    this.alertP = function () {\n        alert(this.p);\n    }\n}\n\nvar point2 = new point();\n```\n\n那么，在使用`new`操作符来调用一个构造函数的时候，发生了什么了呢？其实很简单，就发生了四件事：\n\n```JavaScript\nvar obj = {};\nobj.__proto__ = point.prototype;\npoint.call(obj);\nreturn obj;\n```\n第一行，创建一个空的对象`obj`   \n第二行，将这个对象的`__proto__`成员指向了构造函数对象的`prototype`成员对象，这是最关键的异步，具体细节将在下文描述。    \n第三行，将构造函数的\b作用域赋给新对象，因此`point`函数中的`this`指向新对象`obj`，然后调用`point`。于是我们就给`0bj`对象赋值了一个成员变量`p`，这个成员变量的值就是`'test'`\n","slug":"2019-01-31-JavaScript中的原型链","published":1,"updated":"2019-03-05T14:53:10.035Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjtviomwg000ibtzifoodghmd","content":"<h4 id=\"JavaScript-对象的创建方式\"><a href=\"#JavaScript-对象的创建方式\" class=\"headerlink\" title=\"JavaScript 对象的创建方式\"></a>JavaScript 对象的创建方式</h4><p>在 JavaScript 中，创建对象的方式包括两种：\b<br>1、对象字面量<br>2、使用<code>new</code>表达式<br>对象字面量是一种灵活方便的书写方式，例如:</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> point = &#123;</span><br><span class=\"line\">    p:<span class=\"string\">'test'</span>,</span><br><span class=\"line\">    alertP:<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        alert(<span class=\"keyword\">this</span>.p);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这样就用对象字面量创建了一个对象 p，它具有一个成员变量以及一个 \b 成员方法 \b<code>alertP</code>。这种写法不需要定义构造函数，因此不在本文讨论范围之内。这种写法的缺点是，每创建一个 \b 新的对象都需要写出完整的定义语句，不便于创建大量相同类型的 \b 对象，不利于继承等高级特性。</p>\n<p>new 表达式是配合构造函数使用的，例如<code>new String(&#39;a string&#39;)</code>，调用内置的<code>String</code>函数构造一个字符串对象。下面我们用构造函数的方式来重新创建一个实现同样功能的对象，首先是定义构造函数，然后是用调用<code>new</code>表达式:</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">point</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.p = <span class=\"string\">'test'</span>;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.alertP = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        alert(<span class=\"keyword\">this</span>.p);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> point2 = <span class=\"keyword\">new</span> point();</span><br></pre></td></tr></table></figure>\n<p>那么，在使用<code>new</code>操作符来调用一个构造函数的时候，发生了什么了呢？其实很简单，就发生了四件事：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> obj = &#123;&#125;;</span><br><span class=\"line\">obj.__proto__ = point.prototype;</span><br><span class=\"line\">point.call(obj);</span><br><span class=\"line\"><span class=\"keyword\">return</span> obj;</span><br></pre></td></tr></table></figure>\n<p>第一行，创建一个空的对象<code>obj</code><br>第二行，将这个对象的<code>__proto__</code>成员指向了构造函数对象的<code>prototype</code>成员对象，这是最关键的异步，具体细节将在下文描述。<br>第三行，将构造函数的\b作用域赋给新对象，因此<code>point</code>函数中的<code>this</code>指向新对象<code>obj</code>，然后调用<code>point</code>。于是我们就给<code>0bj</code>对象赋值了一个成员变量<code>p</code>，这个成员变量的值就是<code>&#39;test&#39;</code></p>\n","site":{"data":{}},"excerpt":"","more":"<h4 id=\"JavaScript-对象的创建方式\"><a href=\"#JavaScript-对象的创建方式\" class=\"headerlink\" title=\"JavaScript 对象的创建方式\"></a>JavaScript 对象的创建方式</h4><p>在 JavaScript 中，创建对象的方式包括两种：\b<br>1、对象字面量<br>2、使用<code>new</code>表达式<br>对象字面量是一种灵活方便的书写方式，例如:</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> point = &#123;</span><br><span class=\"line\">    p:<span class=\"string\">'test'</span>,</span><br><span class=\"line\">    alertP:<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        alert(<span class=\"keyword\">this</span>.p);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这样就用对象字面量创建了一个对象 p，它具有一个成员变量以及一个 \b 成员方法 \b<code>alertP</code>。这种写法不需要定义构造函数，因此不在本文讨论范围之内。这种写法的缺点是，每创建一个 \b 新的对象都需要写出完整的定义语句，不便于创建大量相同类型的 \b 对象，不利于继承等高级特性。</p>\n<p>new 表达式是配合构造函数使用的，例如<code>new String(&#39;a string&#39;)</code>，调用内置的<code>String</code>函数构造一个字符串对象。下面我们用构造函数的方式来重新创建一个实现同样功能的对象，首先是定义构造函数，然后是用调用<code>new</code>表达式:</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">point</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.p = <span class=\"string\">'test'</span>;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.alertP = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        alert(<span class=\"keyword\">this</span>.p);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> point2 = <span class=\"keyword\">new</span> point();</span><br></pre></td></tr></table></figure>\n<p>那么，在使用<code>new</code>操作符来调用一个构造函数的时候，发生了什么了呢？其实很简单，就发生了四件事：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> obj = &#123;&#125;;</span><br><span class=\"line\">obj.__proto__ = point.prototype;</span><br><span class=\"line\">point.call(obj);</span><br><span class=\"line\"><span class=\"keyword\">return</span> obj;</span><br></pre></td></tr></table></figure>\n<p>第一行，创建一个空的对象<code>obj</code><br>第二行，将这个对象的<code>__proto__</code>成员指向了构造函数对象的<code>prototype</code>成员对象，这是最关键的异步，具体细节将在下文描述。<br>第三行，将构造函数的\b作用域赋给新对象，因此<code>point</code>函数中的<code>this</code>指向新对象<code>obj</code>，然后调用<code>point</code>。于是我们就给<code>0bj</code>对象赋值了一个成员变量<code>p</code>，这个成员变量的值就是<code>&#39;test&#39;</code></p>\n"},{"title":"详解addEventListener","date":"2019-02-25T08:07:17.000Z","passwords":["f72f3302519ee6484f54a7cbbbdf07e3f92543545a3d3174ee909b23807fdc1f"],"lock":true,"_content":"","source":"_posts/2019-02-25-详解addEventListener.md","raw":"---\ntitle: 详解addEventListener\ndate: 2019-02-25 16:07:17\ntags:\npasswords: \n- f72f3302519ee6484f54a7cbbbdf07e3f92543545a3d3174ee909b23807fdc1f\nlock: true\n---\n","slug":"2019-02-25-详解addEventListener","published":1,"updated":"2019-03-05T15:05:55.107Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjtviomwh000kbtzih9fyfb6r","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"这些年我究竟失去了什么","date":"2019-03-07T07:06:45.000Z","_content":"","source":"_posts/这些年我究竟失去了什么.md","raw":"---\ntitle: 这些年我究竟失去了什么\ndate: 2019-03-07 15:06:45\ntags:\n---\n","slug":"这些年我究竟失去了什么","published":1,"updated":"2019-03-07T07:06:45.550Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjtviomwi000mbtzii45ydnww","content":"","site":{"data":{}},"excerpt":"","more":""}],"PostAsset":[],"PostCategory":[],"PostTag":[{"post_id":"cjtviomvw0001btzir2pme5iu","tag_id":"cjtviomw20004btzimyfv2xn2","_id":"cjtviomw70009btziyq1hpb0y"},{"post_id":"cjtviomw8000abtzi9s1tspnz","tag_id":"cjtviomw70008btzictay8xtt","_id":"cjtviomwc000dbtzi1luyfngx"},{"post_id":"cjtviomw00003btzimhz6ylta","tag_id":"cjtviomw70008btzictay8xtt","_id":"cjtviomwe000fbtzio57owuyj"},{"post_id":"cjtviomw40005btziu2gc3cn9","tag_id":"cjtviomw70008btzictay8xtt","_id":"cjtviomwg000jbtzit9fece7g"},{"post_id":"cjtviomw50006btzigtywtouv","tag_id":"cjtviomw70008btzictay8xtt","_id":"cjtviomwj000nbtzi0oi8l3on"},{"post_id":"cjtviomw60007btzi01h9hd0g","tag_id":"cjtviomw70008btzictay8xtt","_id":"cjtviomwj000pbtzi4ia6u239"},{"post_id":"cjtviomwd000ebtzih7bwilw1","tag_id":"cjtviomwj000obtziknc063oa","_id":"cjtviomwk000qbtzi4cqu8jk3"}],"Tag":[{"name":"-Vue -vscode","_id":"cjtviomw20004btzimyfv2xn2"},{"name":"-Vue","_id":"cjtviomw70008btzictay8xtt"},{"name":"-ES6","_id":"cjtviomwj000obtziknc063oa"}]}}